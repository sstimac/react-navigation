{"CONTRIBUTING":"# React Navigation Contributor Guide\n\nWant to help improve React Navigation? Your help would be greatly appreciated!\n\nHere are some of some of the ways to contribute to the project:\n\n- [Reporting Bugs](#Reporting-Bugs)\n- [Improving the Documentation](#Improving-the-Documentation)\n- [Responding to Issues](#Responding-to-Issues)\n- [Bug Fixes](#Bug-Fixes)\n- [Suggesting a Feature](#Suggesting-a-Feature)\n- [Big Pull Requests](#Big-Pull-Requests)\n\nAnd here are a few helpful resources to aid in getting started:\n\n- [Issue Template](#Issue-Template)\n- [Pull Request Template](#Pull-Request-Template)\n- [Forking the Repository](#Forking-the-Repository)\n- [Code Review Guidelines](#Code-Review-Guidelines)\n- [Run the Example App](#Run-the-Example-App)\n- [Run the Website](#Run-the-Website)\n- [Run Tests and Type-Checking](#Run-Tests-and-Type-Checking)\n\n> Note that we used Yarn in the examples below but you're welcome to use NPM instead.\n\n## Contributing\n\n### Reporting Bugs\n\nYou can't write code without writing the occasional bug. Especially as React Navigation is in beta and moving quickly, bugs happen. When you think you've found one here's what to do:\n\n1. Search the existing issues for one like what you're seeing. If you see one, add a üëç reaction (please no +1 comments). Read through the comments and see if you can provide any more valuable information to the thread\n2. If there are no other issues like yours then create a new one. Be sure to follow the [issue template](https://github.com/react-community/react-navigation/blob/master/.github/ISSUE_TEMPLATE.md).\n\nCreating a high quality reproduction is critical. Without it we likely can't fix the bug and, in an ideal situation, you'll find out that it's not actually a bug of the library but simply done incorrectly in your project. Instant bug fix!\n\n### Improving the Documentation\n\nAny successful projects needs quality documentation and React Navigation is no different.\n\nThe docs are currently organized as follows\n\n- __Getting Started__: Introduction and basics of React Navigation. Help people get up and running with the package quickly. Introduce and demonstrate core functionality.\n- __Navigators__: API documentation for the included navigators and supporting APIs\n- __Advanced Guides__: (Advanced) Beyond the basics, what can you do with React Navigation? Discuss and demonstrate that here.\n- __Routers__: (Advanced) API documentation for the included routers and how to use/customize them\n- __Views__: (Advanced) API documentation for the included views and how to use/customize them\n\nThe documentation isn't fixed to what categories and documents currently exist. If your documentation contributation is appropriate for any existing document, add it there. If it makes sense to create a new document for your contribution please do so and add it to the docs index.\n\nThe docs are indexed in [App.js](https://github.com/react-community/react-navigation/blob/master/website/src/App.js), where all the pages are declared alongside the titles. To test the docs, follow the instructions for running the website.\n\nThe markdown from the `docs` folder gets generated and dumped into a json file as a part of the build step. To see updated docs appear in the website, re-run the build step by running `yarn run build-docs` from the `react-navigation` root folder.\n\n### Responding to Issues\n\nAnother great way to contribute to React Navigation is by responding to issues. Maybe it's answering someone's question, pointing out a small typo in their code, or helping them put together a reproduction. If you're interested in a more active role in React Navigation start with responding to issues - not only is it helpful but it demonstrates your commitment and knowledge of the code!\n\n### Bug Fixes\n\nFind a bug, fix it up, all day long you'll have good luck! Like it was mentioned earlier, bugs happen. If you find a bug do the following:\n\n1. Check if a pull request already exists addressing that bug. If it does give it a review and leave your comments\n2. If there isn't already a pull request then figure out the fix! If it's relatively small go ahead and fix it and submit a pull request. If it's a decent number of changes file an issue first so we can discuss it (see the [Big Pull Requests](#big-pull-requests) section)\n3. If there is an issue related to that bug leave a comment on it, linking to your pull request, so others know it's been addressed.\n\nCheck out the [help wanted](https://github.com/react-community/react-navigation/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22) and [good first issue](https://github.com/react-community/react-navigation/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) tags to see where you can start helping out!\n\n### Suggesting a Feature\n\nIs there something you want to see from React Navigation? Go ahead and open and issue, describe what it is you want to accomplish and why you want to accomplish that. A few things to consider/add\n\n1. Is there already a way to do this and you want to simplify it?\n2. Do you have any thoughts on how to implement this feature? Have you done something similar already?\n\nHold off on submitting feature pull requests until the feature has been discussed. Once the feature has been established and agreed upon, create the pull request (following the [big pull requests](#big-pull-requests) guide).\n\n### Big Pull Requests\n\nFor any changes that will add/remove/modify multiple files in the project (new features or bug fixes) hold off on writing code right away. There's a few reasons for that\n\n1. Big pull requests take a lot of time to review and it's sometimes hard to pick up the context\n2. Often you may not have to make as big of a change as you expect\n\nWith that in mind, here's the suggestion\n\n1. Open an issue and clearly define what it is you want to accomplish and how you intend to accomplish it\n2. Discuss that solution with the community and maintainers. Provide context, establish edge cases, and figure out the design\n3. Decide on a plan of action\n4. Write the code and submit the PR\n5. Review the PR. This can take some time but, if you followed the steps above, hopefully it won't take too much time.\n\nThe reason we want to do this is to save everyone time. Maybe that feature already exists but isn't documented? Or maybe it doesn't fit with the library. Regardless, by discussing a major change up front you're saving your time and others time as well.\n\n## Information\n\n### Issue Template\n\nBefore submitting and issue please take a look at the [issue template](https://github.com/react-community/react-navigation/blob/master/.github/ISSUE_TEMPLATE.md) and follow it. This is in place to help everyone better understand the issue you're having and reduce the back and forth to get the necessary information.\n\nYes, it takes time and effort to complete the issue template. But that's the only way to ask high quality questions that actually get responses.\n\nWould you rather take 1 minute to create an incomplete issue report and wait months to get any sort of response? Or would you rather take 20 minutes to fill out a high quality issue report, with all the necessary elements, and get a response in days? It's also a respectful thing to do for anyone willing to take the time to review your issue.\n\n### Pull Request Template\n\nMuch like the issue template, the [pull request template](https://github.com/react-community/react-navigation/blob/master/.github/PULL_REQUEST_TEMPLATE.md) lays out instructions to ensure your pull request gets reviewd in a timely manner and reduces the back and forth. Make sure to look it over before you start writing any code.\n\n### Forking the Repository\n\n- Fork [`react-navigation`](https://github.com/react-community/react-navigation) on GitHub\n- Run these commands in the terminal to download locally and install it:\n\n```bash\ngit clone https://github.com/<USERNAME>/react-navigation.git\ncd react-navigation\ngit remote add upstream https://github.com/react-community/react-navigation.git\nyarn install\n```\n\n### Code Review Guidelines\n\nLook around. Match the style of the reset of the codebase. This project uses ESLint and Flow to ensure consistency throughout the project. You can check your project by running\n\n```bash\nyarn run eslint\nyarn run flow-check\n```\n\nIf any errors occur you'll either have to manually fix them or you can attempt to automatically fix them by running `yarn run format`.\n\n### Run the Example App\n\n```bash\nyarn install\ncd examples/NavigationPlayground\nyarn install\nyarn start\n```\n\nYou will be show a QR code to scan in the Expo app. You can get Expo [here](https://docs.expo.io/versions/latest/index.html) if you don't have it yet.\n\nAll examples:\n\n- [NavigationPlayground](https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground)\n- [ReduxExample](https://github.com/react-community/react-navigation/tree/master/examples/ReduxExample)\n- [SafeAreaExample](https://github.com/react-community/react-navigation/tree/master/examples/SafeAreaExample)\n\nCommands are the same as above for any of the example apps. If you run into any issues, please try the following to start fresh:\n\n```bash\nwatchman watch-del-all\nyarn start -- --reset-cache\n```\n\n### Run the Website\n\nFor development mode and live-reloading:\n\n```bash\ncd website\nyarn install\nyarn start\n```\n\nTo run the website in production mode with server rendering:\n\n```bash\nyarn run prod\n```\n\nIf you've made any changes to the `docs` directory you'll need to run `yarn run build-docs` from the root of the project before they're picked up by the website.\n\n### Run Tests and Type-Checking\n\nReact Navigation has tests implemented in [Jest](https://facebook.github.io/jest/) and type-checking is managed by [Flow](https://flow.org/). To run either of these, from the React Navigation directory, run either of the following commands (after installing the `node_modules`) to run tests or type-checking.\n\n```bash\nyarn run jest\nyarn run flow-check\n```\n\nThese commands will be run by our CI and are required to pass before any contributtions are merged.\n","api/navigators/DrawerNavigator":"# DrawerNavigator\n\nUsed to easily set up a screen with a drawer navigation. For a live example please see [our expo demo](https://exp.host/@react-navigation/NavigationPlayground).\n\n```js\nclass MyHomeScreen extends React.Component {\n  static navigationOptions = {\n    drawerLabel: 'Home',\n    drawerIcon: ({ tintColor }) => (\n      <Image\n        source={require('./chats-icon.png')}\n        style={[styles.icon, {tintColor: tintColor}]}\n      />\n    ),\n  };\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.navigate('Notifications')}\n        title=\"Go to notifications\"\n      />\n    );\n  }\n}\n\nclass MyNotificationsScreen extends React.Component {\n  static navigationOptions = {\n    drawerLabel: 'Notifications',\n    drawerIcon: ({ tintColor }) => (\n      <Image\n        source={require('./notif-icon.png')}\n        style={[styles.icon, {tintColor: tintColor}]}\n      />\n    ),\n  };\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.goBack()}\n        title=\"Go back home\"\n      />\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  icon: {\n    width: 24,\n    height: 24,\n  },\n});\n\nconst MyApp = DrawerNavigator({\n  Home: {\n    screen: MyHomeScreen,\n  },\n  Notifications: {\n    screen: MyNotificationsScreen,\n  },\n});\n```\n\nTo open and close drawer, navigate to `'DrawerOpen'` and `'DrawerClose'` respectively.\n\n```js\nthis.props.navigation.navigate('DrawerOpen'); // open drawer\nthis.props.navigation.navigate('DrawerClose'); // close drawer\n```\nIf you would like to toggle the drawer you can navigate to `'DrawerToggle'`, and this will choose which navigation is appropriate for you given the drawers current state.\n\n```js\n// fires 'DrawerOpen'/'DrawerClose' accordingly\nthis.props.navigation.navigate('DrawerToggle');\n```\n\n## API Definition\n\n```js\nDrawerNavigator(RouteConfigs, DrawerNavigatorConfig)\n```\n\n### RouteConfigs\n\nThe route configs object is a mapping from route name to a route config, which tells the navigator what to present for that route, see [example](/docs/api/navigators/StackNavigator.md#routeconfigs) from `StackNavigator`.\n\n\n### DrawerNavigatorConfig\n- `drawerWidth` - Width of the drawer or a function returning it.\n- `drawerPosition` - Options are `left` or `right`. Default is `left` position.\n- `contentComponent` - Component used to render the content of the drawer, for example, navigation items. Receives the `navigation` prop for the drawer. Defaults to `DrawerItems`. For more information, see below.\n- `contentOptions` - Configure the drawer content, see below.\n- `useNativeAnimations` - Enable native animations. Default is `true`.\n- `drawerBackgroundColor` - Use the Drawer background for some color. The Default is `white`.\n\nSeveral options get passed to the underlying router to modify navigation logic:\n\n- `initialRouteName` - The routeName for the initial route.\n- `order` - Array of routeNames which defines the order of the drawer items.\n- `paths` - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs.\n- `backBehavior` - Should the back button cause switch to the initial route? If yes, set to `initialRoute`, otherwise `none`. Defaults to `initialRoute` behavior.\n\n### Providing a custom `contentComponent`\n\nThe default component for the drawer is scrollable and only contains links for the routes in the RouteConfig. You can easily override the default component to add a header, footer, or other content to the drawer. By default the drawer is scrollable and supports iPhone X safe area. If you customize the content, be sure to wrap the content in a SafeAreaView:\n\n```js\nimport { DrawerItems, SafeAreaView } from 'react-navigation';\n\nconst CustomDrawerContentComponent = (props) => (\n  <ScrollView>\n    <SafeAreaView style={styles.container} forceInset={{ top: 'always', horizontal: 'never' }}>\n      <DrawerItems {...props} />\n    </SafeAreaView>\n  </ScrollView>\n);\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n```\n\n### `contentOptions` for `DrawerItems`\n\n- `items` - the array of routes, can be modified or overridden\n- `activeItemKey` - key identifying the active route\n- `activeTintColor` - label and icon color of the active label\n- `activeBackgroundColor` - background color of the active label\n- `inactiveTintColor` - label and icon color of the inactive label\n- `inactiveBackgroundColor` - background color of the inactive label\n- `onItemPress(route)` - function to be invoked when an item is pressed\n- `itemsContainerStyle` - style object for the content section\n- `itemStyle` - style object for the single item, which can contain an Icon and/or a Label\n- `labelStyle` - style object to overwrite `Text` style inside content section, when your label is a string\n- `iconContainerStyle` - style object to overwrite `View` icon container styles.\n\n#### Example:\n\n```js\ncontentOptions: {\n  activeTintColor: '#e91e63',\n  itemsContainerStyle: {\n    marginVertical: 0,\n  },\n  iconContainerStyle: {\n    opacity: 1\n  }\n}\n```\n\n### Screen Navigation Options\n\n#### `title`\n\nGeneric title that can be used as a fallback for `headerTitle` and `drawerLabel`\n\n#### `drawerLabel`\n\nString, React Element or a function that given `{ focused: boolean, tintColor: string }` returns a React.Node, to display in drawer sidebar. When undefined, scene `title` is used\n\n#### `drawerIcon`\n\nReact Element or a function, that given `{ focused: boolean, tintColor: string }` returns a React.Node, to display in drawer sidebar\n\n#### `drawerLockMode`\n\nSpecifies the [lock mode](https://facebook.github.io/react-native/docs/drawerlayoutandroid.html#drawerlockmode) of the drawer. This can also update dynamically by using screenProps.drawerLockMode on your top level router.\n\n### Navigator Props\n\nThe navigator component created by `DrawerNavigator(...)` takes the following props:\n\n- `screenProps` - Pass down extra options to child screens, for example:\n\n\n ```jsx\n const DrawerNav = DrawerNavigator({\n   // config\n });\n\n <DrawerNav\n   screenProps={/* this prop will get passed to the screen components and nav options as props.screenProps */}\n />\n ```\n\n ### Nesting `DrawerNavigation`\n\nPlease bear in mind that if you nest the DrawerNavigation, the drawer will show below the parent navigation.\n","api/navigators/Navigators":"# Navigators\n\nNavigators allow you to define your application's navigation structure. Navigators also render common elements such as headers and tab bars which you can configure.\n\nUnder the hood, navigators are plain React components.\n\n## Built-in Navigators\n\n`react-navigation` includes the following functions to help you create navigators:\n\n- [StackNavigator](/docs/navigators/stack) - Renders one screen at a time and provides transitions between screens. When a new screen is opened it is placed on top of the stack.\n- [TabNavigator](/docs/navigators/tab) - Renders a tab bar that lets the user switch between several screens\n- [DrawerNavigator](/docs/navigators/drawer) - Provides a drawer that slides in from the left of the screen\n\n## Rendering screens with Navigators\n\nThe navigators render application screens which are just React components.\n\nTo learn how to create screens, read about:\n- [Screen `navigation` prop](/docs/navigators/navigation-prop) to allow the screen to dispatch navigation actions, such as opening another screen\n- [Screen `navigationOptions`](/docs/navigators/navigation-options) to customize how the screen gets presented by the navigator (e.g. header title, tab label)\n\n### Calling Navigate on Top Level Component\n\nIn case you want to use Navigator from the same level you declare it you can use react's [`ref`](https://facebook.github.io/react/docs/refs-and-the-dom.html#the-ref-callback-attribute) option:  \n```js\nimport { NavigationActions } from 'react-navigation';\n\nconst AppNavigator = StackNavigator(SomeAppRouteConfigs);\n\nclass App extends React.Component {\n  someEvent() {\n    // call navigate for AppNavigator here:\n    this.navigator && this.navigator.dispatch(\n      NavigationActions.navigate({ routeName: someRouteName })\n    );\n  }\n  render() {\n    return (\n      <AppNavigator ref={nav => { this.navigator = nav; }} />\n    );\n  }\n}\n```\nPlease notice that this solution should only be used on the top level navigator.  \n\n## Navigation Containers\n\nThe built in navigators can automatically behave like top-level navigators when the navigation prop is missing. This functionality provides a transparent navigation container, which is where the top-level navigation prop comes from.\n\nWhen rendering one of the included navigators, the navigation prop is optional. When it is missing, the container steps in and manages its own navigation state. It also handles URLs, external linking, and Android back button integration.\n\nFor the purpose of convenience, the built-in navigators have this ability because behind the scenes they use `createNavigationContainer`. Usually, navigators require a navigation prop in order to function.\n\nTop-level navigators accept the following props:  \n\n### `onNavigationStateChange(prevState, newState, action)`\n\nFunction that gets called every time navigation state managed by the navigator changes. It receives the previous state, the new state of the navigation and the action that issued state change. By default it prints state changes to the console.\n\n### `uriPrefix`\n\nThe prefix of the URIs that the app might handle. This will be used when handling a [deep link](/docs/guides/linking) to extract the path passed to the router.\n","api/navigators/StackNavigator":"# StackNavigator\n\nProvides a way for your app to transition between screens where each new screen is placed on top of a stack.\n\nBy default the StackNavigator is configured to have the familiar iOS and Android look & feel: new screens slide in from the right on iOS, fade in from the bottom on Android. On iOS the StackNavigator can also be configured to a modal style where screens slide in from the bottom.\n\n```jsx\n\nclass MyHomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Home',\n  }\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.navigate('Profile', {name: 'Lucy'})}\n        title=\"Go to Lucy's profile\"\n      />\n    );\n  }\n}\n\nconst ModalStack = StackNavigator({\n  Home: {\n    screen: MyHomeScreen,\n  },\n  Profile: {\n    path: 'people/:name',\n    screen: MyProfileScreen,\n  },\n});\n```\n\n## API Definition\n\n```js\nStackNavigator(RouteConfigs, StackNavigatorConfig)\n```\n\n### RouteConfigs\n\nThe route configs object is a mapping from route name to a route config, which tells the navigator what to present for that route.\n\n```js\nStackNavigator({\n\n  // For each screen that you can navigate to, create a new entry like this:\n  Profile: {\n\n    // `ProfileScreen` is a React component that will be the main content of the screen.\n    screen: ProfileScreen,\n    // When `ProfileScreen` is loaded by the StackNavigator, it will be given a `navigation` prop.\n\n    // Optional: When deep linking or using react-navigation in a web app, this path is used:\n    path: 'people/:name',\n    // The action and route params are extracted from the path.\n\n    // Optional: Override the `navigationOptions` for the screen\n    navigationOptions: ({navigation}) => ({\n      title: `${navigation.state.params.name}'s Profile'`,\n    }),\n  },\n\n  ...MyOtherRoutes,\n});\n```\n\n### StackNavigatorConfig\n\nOptions for the router:\n\n- `initialRouteName` - Sets the default screen of the stack. Must match one of the keys in route configs.\n- `initialRouteParams` - The params for the initial route\n- `navigationOptions` - Default navigation options to use for screens\n- `paths` - A mapping of overrides for the paths set in the route configs\n\nVisual options:\n\n- `mode` - Defines the style for rendering and transitions:\n  - `card` - Use the standard iOS and Android screen transitions. This is the default.\n  - `modal` - Make the screens slide in from the bottom which is a common iOS pattern. Only works on iOS, has no effect on Android.\n- `headerMode` - Specifies how the header should be rendered:\n  - `float` - Render a single header that stays at the top and animates as screens are changed. This is a common pattern on iOS.\n  - `screen` - Each screen has a header attached to it and the header fades in and out together with the screen. This is a common pattern on Android.\n  - `none` - No header will be rendered.\n- `cardStyle` - Use this prop to override or extend the default style for an individual card in stack.\n- `transitionConfig` - Function to return an object that is merged with the default screen transitions (take a look at TransitionConfig in [type definitions](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js)). Provided function will be passed the following arguments:\n\t- `transitionProps` - Transition props for the new screen.\n\t- `prevTransitionProps` - Transitions props for the old screen.\n\t- `isModal` - Boolean specifying if screen is modal.\n- `onTransitionStart` - Function to be invoked when the card transition animation is about to start.\n- `onTransitionEnd` - Function to be invoked once the card transition animation completes.\n\n\n### Screen Navigation Options\n\n#### `title`\n\nString that can be used as a fallback for `headerTitle`. Additionally, will be used as a fallback for `tabBarLabel` (if nested in a TabNavigator) or `drawerLabel` (if nested in a DrawerNavigator). \n\n#### `header`\n\nReact Element or a function that given `HeaderProps` returns a React Element, to display as a header. Setting to `null` hides header.\n\n#### `headerTitle`\n\nString, React Element or React Component used by the header. Defaults to scene `title`. When a component is used, it receives `allowFontScaling`, `style` and `children` props. The title string is passed in `children`.\n\n#### `headerTitleAllowFontScaling`\n\nWhether header title font should scale to respect Text Size accessibility settings. Defaults to true.\n\n#### `headerBackTitle`\n\nTitle string used by the back button on iOS, or `null` to disable label. Defaults to the previous scene's `headerTitle`.\n\n#### `headerTruncatedBackTitle`\n\nTitle string used by the back button when `headerBackTitle` doesn't fit on the screen. `\"Back\"` by default.\n\n#### `headerRight`\n\nReact Element to display on the right side of the header.\n\n#### `headerLeft`\n\nReact Element or Component to display on the left side of the header. When a component is used, it receives a number of props when rendered (`onPress`, `title`, `titleStyle` and more - check `Header.js` for the complete list).\n\n#### `headerStyle`\n\nStyle object for the header\n\n#### `headerTitleStyle`\n\nStyle object for the title component\n\n#### `headerBackTitleStyle`\n\nStyle object for the back title\n\n#### `headerTintColor`\n\nTint color for the header\n\n#### `headerPressColorAndroid`\n\nColor for material ripple (Android >= 5.0 only)\n\n#### `gesturesEnabled`\n\nWhether you can use gestures to dismiss this screen. Defaults to true on iOS, false on Android.\n\n#### `gestureResponseDistance`\n\nObject to override the distance of touch start from the edge of the screen to recognize gestures. It takes the following properties:\n\n- `horizontal` - *number* - Distance for horizontal direction. Defaults to 25.\n- `vertical` - *number* - Distance for vertical direction. Defaults to 135.\n\n#### `gestureDirection`\n\nString to override the direction for dismiss gesture. `default` for normal behaviour or `inverted` for right-to-left swipes.\n\n### Navigator Props\n\nThe navigator component created by `StackNavigator(...)` takes the following props:\n\n- `screenProps` - Pass down extra options to child screens, for example:\n\n\n ```jsx\n const SomeStack = StackNavigator({\n   // config\n });\n\n <SomeStack\n   screenProps={/* this prop will get passed to the screen components as this.props.screenProps */}\n />\n ```\n\n### Examples\n\nSee the examples [SimpleStack.js](https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground/js/SimpleStack.js) and [ModalStack.js](https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground/js/ModalStack.js) which you can run locally as part of the [NavigationPlayground](https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground) app.\n\nYou can view these examples directly on your phone by visiting [our expo demo](https://exp.host/@react-navigation/NavigationPlayground).\n\n#### Modal StackNavigator with Custom Screen Transitions\n\n ```js\nconst ModalNavigator = StackNavigator(\n  {\n    Main: { screen: Main },\n    Login: { screen: Login },\n  },\n  {\n    headerMode: 'none',\n    mode: 'modal',\n    navigationOptions: {\n      gesturesEnabled: false,\n    },\n    transitionConfig: () => ({\n      transitionSpec: {\n        duration: 300,\n        easing: Easing.out(Easing.poly(4)),\n        timing: Animated.timing,\n      },\n      screenInterpolator: sceneProps => {\n        const { layout, position, scene } = sceneProps;\n        const { index } = scene;\n\n        const height = layout.initHeight;\n        const translateY = position.interpolate({\n          inputRange: [index - 1, index, index + 1],\n          outputRange: [height, 0, 0],\n        });\n\n        const opacity = position.interpolate({\n          inputRange: [index - 1, index - 0.99, index],\n          outputRange: [0, 1, 1],\n        });\n\n        return { opacity, transform: [{ translateY }] };\n      },\n    }),\n  }\n);\n ```\n\nHeader transitions can also be configured using `headerLeftInterpolator`, `headerTitleInterpolator` and `headerRightInterpolator` fields under `transitionConfig`.\n","api/navigators/TabNavigator":"# TabNavigator\n\nUsed to easily set up a screen with several tabs with a TabRouter. For a live example please see [our expo demo](https://exp.host/@react-navigation/NavigationPlayground).\n\n```js\nclass MyHomeScreen extends React.Component {\n  static navigationOptions = {\n    tabBarLabel: 'Home',\n    // Note: By default the icon is only shown on iOS. Search the showIcon option below.\n    tabBarIcon: ({ tintColor }) => (\n      <Image\n        source={require('./chats-icon.png')}\n        style={[styles.icon, {tintColor: tintColor}]}\n      />\n    ),\n  };\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.navigate('Notifications')}\n        title=\"Go to notifications\"\n      />\n    );\n  }\n}\n\nclass MyNotificationsScreen extends React.Component {\n  static navigationOptions = {\n    tabBarLabel: 'Notifications',\n    tabBarIcon: ({ tintColor }) => (\n      <Image\n        source={require('./notif-icon.png')}\n        style={[styles.icon, {tintColor: tintColor}]}\n      />\n    ),\n  };\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.goBack()}\n        title=\"Go back home\"\n      />\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  icon: {\n    width: 26,\n    height: 26,\n  },\n});\n\nconst MyApp = TabNavigator({\n  Home: {\n    screen: MyHomeScreen,\n  },\n  Notifications: {\n    screen: MyNotificationsScreen,\n  },\n}, {\n  tabBarPosition: 'top',\n  animationEnabled: true,\n  tabBarOptions: {\n    activeTintColor: '#e91e63',\n  },\n});\n```\n\n## API Definition\n\n```js\nTabNavigator(RouteConfigs, TabNavigatorConfig)\n```\n\n### RouteConfigs\n\nThe route configs object is a mapping from route name to a route config, which tells the navigator what to present for that route, see [example](/docs/api/navigators/StackNavigator.md#routeconfigs) from `StackNavigator`.\n\n### TabNavigatorConfig\n\n- `tabBarComponent` - Component to use as the tab bar, e.g. `TabBarBottom`\n(this is the default on iOS), `TabBarTop`\n(this is the default on Android).\n- `tabBarPosition` - Position of the tab bar, can be `'top'` or `'bottom'`.\n- `swipeEnabled` - Whether to allow swiping between tabs.\n- `animationEnabled` - Whether to animate when changing tabs.\n- `configureTransition` - a function that, given `currentTransitionProps` and `nextTransitionProps`, returns a configuration object that describes the animation between tabs.\n- `initialLayout` - Optional object containing the initial `height` and `width`, can be passed to prevent the one frame delay in [react-native-tab-view](https://github.com/react-native-community/react-native-tab-view#avoid-one-frame-delay) rendering.\n- `tabBarOptions` - Configure the tab bar, see below.\n\nSeveral options get passed to the underlying router to modify navigation logic:\n\n- `initialRouteName` - The routeName for the initial tab route when first loading.\n- `order` - Array of routeNames which defines the order of the tabs.\n- `paths` - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs.\n- `backBehavior` - Should the back button cause a tab switch to the initial tab? If yes, set to `initialRoute`, otherwise `none`. Defaults to `initialRoute` behavior.\n\n### `tabBarOptions` for `TabBarBottom` (default tab bar on iOS)\n\n- `activeTintColor` - Label and icon color of the active tab.\n- `activeBackgroundColor` - Background color of the active tab.\n- `inactiveTintColor` - Label and icon color of the inactive tab.\n- `inactiveBackgroundColor` - Background color of the inactive tab.\n- `showLabel` - Whether to show label for tab, default is true.\n- `style` - Style object for the tab bar.\n- `labelStyle` - Style object for the tab label.\n- `tabStyle` - Style object for the tab.\n- `allowFontScaling` - Whether label font should scale to respect Text Size accessibility settings, default is true.\n\nExample:\n\n```js\ntabBarOptions: {\n  activeTintColor: '#e91e63',\n  labelStyle: {\n    fontSize: 12,\n  },\n  style: {\n    backgroundColor: 'blue',\n  },\n}\n```\n\n### `tabBarOptions` for `TabBarTop` (default tab bar on Android)\n\n- `activeTintColor` - Label and icon color of the active tab.\n- `inactiveTintColor` - Label and icon color of the inactive tab.\n- `showIcon` - Whether to show icon for tab, default is false.\n- `showLabel` - Whether to show label for tab, default is true.\n- `upperCaseLabel` - Whether to make label uppercase, default is true.\n- `pressColor` - Color for material ripple (Android >= 5.0 only).\n- `pressOpacity` - Opacity for pressed tab (iOS and Android < 5.0 only).\n- `scrollEnabled` - Whether to enable scrollable tabs.\n- `tabStyle` - Style object for the tab.\n- `indicatorStyle` - Style object for the tab indicator (line at the bottom of the tab).\n- `labelStyle` - Style object for the tab label.\n- `iconStyle` - Style object for the tab icon.\n- `style` - Style object for the tab bar.\n- `allowFontScaling` - Whether label font should scale to respect Text Size accessibility settings, default is true.\n\nExample:\n\n```js\ntabBarOptions: {\n  labelStyle: {\n    fontSize: 12,\n  },\n  tabStyle: {\n    width: 100,    \n  },\n  style: {\n    backgroundColor: 'blue',\n  },\n}\n```\n\n### Screen Navigation Options\n\n#### `title`\n\nGeneric title that can be used as a fallback for `headerTitle` and `tabBarLabel`.\n\n#### `tabBarVisible`\n\nTrue or false to show or hide the tab bar, if not set then defaults to true.\n\n#### `swipeEnabled`\n\nTrue or false to enable or disable swiping between tabs, if not set then defaults to TabNavigatorConfig option swipeEnabled.\n\n#### `tabBarIcon`\n\nReact Element or a function that given `{ focused: boolean, tintColor: string }` returns a React.Node, to display in tab bar.\n\n#### `tabBarLabel`\n\nTitle string of a tab displayed in the tab bar or React Element or a function that given `{ focused: boolean, tintColor: string }` returns a React.Node, to display in tab bar. When undefined, scene `title` is used. To hide, see `tabBarOptions.showLabel` in the previous section.\n\n#### `tabBarOnPress`\n\nCallback to handle tap events; the argument is an object containing:\n\n* the `previousScene: { route, index }` which is the scene we are leaving\n* the `scene: { route, index }` that was tapped\n* the `jumpToIndex` method that can perform the navigation for you\n\nUseful for adding a custom logic before the transition to the next scene (the tapped one) starts.\n\n### Navigator Props\n\nThe navigator component created by `TabNavigator(...)` takes the following props:\n\n- `screenProps` - Pass down extra options to child screens and navigation options, for example:\n\n\n ```jsx\n const TabNav = TabNavigator({\n   // config\n });\n\n <TabNav\n   screenProps={/* this prop will get passed to the screen components as this.props.screenProps */}\n />\n ```\n","api/routers/Routers":"# Routers\n\nRouters define a component's navigation state, and they allow the developer to define paths and actions that can be handled.\n\n\n## Built-In Routers\n\n`react-navigation` ships with a few standard routers:\n\n- [StackRouter](/docs/routers/stack)\n- [TabRouter](/docs/routers/tab)\n\n\n## Using Routers\n\nTo make a navigator manually, put a static `router` on a component. (To quickly make a navigator with a built-in component, it may be easier to use a [built-in navigator](/docs/navigators) instead)\n\n```js\nclass MyNavigator extends React.Component {\n    static router = StackRouter(routes, config);\n    ...\n}\n```\n\nNow you can use this component as a `screen` in another navigator, and the navigation logic for `MyNavigator` will be defined by this `StackRouter`.\n\n\n## Customizing Routers\n\nSee the [Custom Router API spec](/docs/routers/api) to learn about the API of `StackRouter` and `TabRouter`. You can override the router functions as you see fit:\n\n### Custom Navigation Actions\n\nTo override navigation behavior, you can override the navigation state logic in `getStateForAction`, and manually manipulate the `routes` and `index`.\n\n```js\nconst MyApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Profile: { screen: ProfileScreen },\n}, {\n  initialRouteName: 'Home',\n})\n\nconst defaultGetStateForAction = MyApp.router.getStateForAction;\n\nMyApp.router.getStateForAction = (action, state) => {\n  if (state && action.type === 'PushTwoProfiles') {\n    const routes = [\n      ...state.routes,\n      {key: 'A', routeName: 'Profile', params: { name: action.name1 }},\n      {key: 'B', routeName: 'Profile', params: { name: action.name2 }},\n    ];\n    return {\n      ...state,\n      routes,\n      index: routes.length - 1,\n    };\n  }\n  return defaultGetStateForAction(action, state);\n};\n```\n\n### Blocking Navigation Actions\n\nSometimes you may want to prevent some navigation activity, depending on your route.\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst MyStackRouter = StackRouter({\n  Home: { screen: HomeScreen },\n  Profile: { screen: ProfileScreen },\n}, {\n  initialRouteName: 'Home',\n})\n\nconst defaultGetStateForAction = MyStackRouter.router.getStateForAction;\n\nMyStackRouter.router.getStateForAction = (action, state) => {\n  if (\n    state &&\n    action.type === NavigationActions.BACK &&\n    state.routes[state.index].params.isEditing\n  ) {\n    // Returning null from getStateForAction means that the action\n    // has been handled/blocked, but there is not a new state\n    return null;\n  }\n  \n  return defaultGetStateForAction(action, state);\n};\n```\n\n\n### Handling Custom URIs\n\nPerhaps your app has a unique URI which the built-in routers cannot handle. You can always extend the router `getActionForPathAndParams`.\n\n```js\n\nimport { NavigationActions } from 'react-navigation'\n\nconst MyApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Profile: { screen: ProfileScreen },\n}, {\n  initialRouteName: 'Home',\n})\nconst previousGetActionForPathAndParams = MyApp.router.getActionForPathAndParams;\n\nObject.assign(MyApp.router, {\n  getActionForPathAndParams(path, params) {\n    if (\n      path === 'my/custom/path' &&\n      params.magic === 'yes'\n    ) {\n      // returns a profile navigate action for /my/custom/path?magic=yes\n      return NavigationActions.navigate({\n        routeName: 'Profile',\n        action: NavigationActions.navigate({\n          // This child action will get passed to the child router\n          // ProfileScreen.router.getStateForAction to get the child\n          // navigation state.\n          routeName: 'Friends',\n        }),\n      });\n    }\n    return previousGetActionForPathAndParams(path, params);\n  },\n});\n```\n","api/routers/RoutersAPI":"## Custom Router API\n\nYou can make your own router by building an object with the following functions:\n\n```js\nconst MyRouter = {\n  getStateForAction: (action, state) => ({}),\n  getActionForPathAndParams: (path, params) => null,\n  getPathAndParamsForState: (state) => null,\n  getComponentForState: (state) => MyScreen,\n  getComponentForRouteName: (routeName) => MyScreen,\n};\n\n// Now, you can make a navigator by putting the router on it:\nclass MyNavigator extends React.Component {\n  static router = MyRouter;\n  render() {\n    ...\n  }\n}\n```\n\n![Routers manage the relationship between URIs, actions, and navigation state](/assets/routers-concept-map.png)\n\n\n### `getStateForAction(action, state)`\n\nDefines the navigation state in response to a given action. This function will be run when an action gets passed into `props.navigation.dispatch(`, or when any of the helper functions are called, like `navigation.navigate(`.\n\nTypically this should return a navigation state, with the following form:\n\n```\n{\n  index: 1, // identifies which route in the routes array is active\n  routes: [\n    {\n      // Each route needs a name to identify the type.\n      routeName: 'MyRouteName',\n\n      // A unique identifier for this route in the routes array:\n      key: 'myroute-123',\n      // (used to specify the re-ordering of routes)\n\n      // Routes can have any data, as long as key and routeName are correct\n      ...randomRouteData,\n    },\n    ...moreRoutes,\n  ]\n}\n```\n\nIf the router has handled the action externally, or wants to swallow it without changing the navigation state, this function will return `null`.\n\n### `getComponentForRouteName(routeName)`\n\nReturns the child component or navigator for the given route name.\n\nSay a router `getStateForAction` outputs a state like this:\n```js\n{\n  index: 1,\n  routes: [\n    { key: 'A', routeName: 'Foo' },\n    { key: 'B', routeName: 'Bar' },\n  ],\n}\n```\n\nBased on the routeNames in the state, the router is responsible for returning valid components when calling `router.getComponentForRouteName('Foo')` or `router.getComponentForRouteName('Bar')`.\n\n### `getComponentForState(state)`\n\nReturns the active component for a deep navigation state.\n\n### `getActionForPathAndParams(path, params)`\n\nReturns an optional navigation action that should be used when the user navigates to this path and provides optional query parameters.\n\n### `getPathAndParamsForState(state)`\n\nReturns the path and params that can be put into the URL to link the user back to the same spot in the app.\n\nThe path/params that are output from this should form an action when passed back into the router's `getActionForPathAndParams`. That action should take you to a similar state once passed through `getStateForAction`.\n\n### `getScreenOptions(navigation, screenProps)`\n\nUsed to retrieve the navigation options for a screen. Must provide the screen's current navigation prop and optionally, other props that your navigation options may need to consume.\n\n- `navigation` - This is the navigation prop that the screen will use, where the state refers to the screen's route/state. Dispatch will trigger actions in the context of that screen.\n- `screenProps` - Other props that your navigation options may need to consume\n- `navigationOptions` - The previous set of options that are default or provided by the previous configurer\n\nInside an example view, perhaps you need to fetch the configured title:\n```js\n// First, prepare a navigation prop for your child, or re-use one if already available.\nconst screenNavigation = addNavigationHelpers({\n  // In this case we use navigation.state.index because we want the title for the active route.\n  state: navigation.state.routes[navigation.state.index],\n  dispatch: navigation.dispatch,\n});\nconst options = this.props.router.getScreenOptions(screenNavigation, {});\nconst title = options.title;\n```\n","api/routers/StackRouter":"# StackRouter\n\nManage the logical navigation stack, including pushing, popping, and handling path parsing to create a deep stack.\n\nLet's take a look at a simple stack router:\n\n```js\nconst MyApp = StackRouter({\n  Home: { screen: HomeScreen },\n  Profile: { screen: ProfileScreen },\n}, {\n  initialRouteName: 'Home',\n})\n```\n\n\n### RouteConfig\n\nA basic stack router expects a route config object. Here is an example configuration:\n\n```js\nconst MyApp = StackRouter({ // This is the RouteConfig:\n  Home: {\n    screen: HomeScreen,\n    path: '',\n  },\n  Profile: {\n    screen: ProfileScreen,\n    path: 'profile/:name',\n  },\n  Settings: {\n    // This can be handy to lazily require a screen:\n    getScreen: () => require('Settings').default,\n    // Note: Child navigators cannot be configured using getScreen because\n    // the router will not be accessible. Navigators must be configured\n    // using `screen: MyNavigator`\n    path: 'settings',\n  },\n});\n```\n\nEach item in the config may have the following:\n\n- `path` - Specify the path and params to be parsed for item in the stack\n- `screen` - Specify the screen component or child navigator\n- `getScreen` - Set a lazy getter for a screen component (but not navigators)\n\n\n### StackConfig\n\nConfig options that are also passed to the stack router.\n\n- `initialRouteName` - The routeName for the default route when the stack first loads\n- `initialRouteParams` - Default params of the initial route\n- `paths` - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs.\n\n### Supported Actions\n\nThe stack router may respond to the following navigation actions. The router will generally delegate the action handling to a child router, if possible.\n\n- Navigate - Will push a new route on the stack if the routeName matches one of the router's routeConfigs\n- Back - Goes back (pops)\n- Reset - Clears the stack and provides new actions to create a fully new navigation state\n- SetParams - An action that a screen dispatches to change the params of the current route.\n","api/routers/TabRouter":"# TabRouter\n\nManage a set of tabs in the application, handle jumping to tabs, and handle the back button press to jump to the initial tab.\n\nLet's take a look at a simple tabs router:\n\n```js\nconst MyApp = TabRouter({\n  Home: { screen: HomeScreen },\n  Settings: { screen: SettingsScreen },\n}, {\n  initialRouteName: 'Home',\n})\n```\n\n\n### RouteConfig\n\nA tabs router has a routeConfig for each possible tab:\n\n```js\nconst MyApp = TabRouter({ // This is the RouteConfig:\n  Home: {\n    screen: HomeScreen,\n    path: 'main',\n  },\n  Settings: {\n    // This can be handy to lazily require a tab:\n    getScreen: () => require('./SettingsScreen').default,\n    // Note: Child navigators cannot be configured using getScreen because\n    // the router will not be accessible. Navigators must be configured\n    // using `screen: MyNavigator`\n    path: 'settings',\n  },\n});\n```\n\nEach item in the config may have the following:\n\n- `path` - Specify the path for each tab\n- `screen` - Specify the screen component or child navigator\n- `getScreen` - Set a lazy getter for a screen component (but not navigators)\n\n\n### Tab Router Config\n\nConfig options that are also passed to the router.\n\n- `initialRouteName` - The routeName for the initial tab route when first loading\n- `order` - Array of routeNames which defines the order of the tabs\n- `paths` - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs.\n- `backBehavior` - Should the back button cause a tab switch to the initial tab? If yes, set to `initialRoute`, otherwise `none`. Defaults to `initialRoute` behavior.\n\n### Supported Actions\n\nThe tabs router may respond to the following navigation actions. The router will generally delegate the action handling to a child router, if possible.\n\n- Navigate - Will jump to the routeName if it matches a tab\n- Back - Goes to the first tab, if not already selected\n- SetParams - An action that a screen dispatches to change the params of the current route.\n","api/views/Transitioner":"# Transitioner\n\n`Transitioner` is a React component that helps manage transitions for complex animated components. It manages the timing of animations and keeps track of various screens as they enter and leave, but it doesn't know what anything looks like, because rendering is entirely deferred to the developer.\n\nUnder the covers, `Transitioner` is used to implement `CardStack`, and hence the `StackNavigator`.\n\nThe most useful thing `Transitioner` does is to take in a prop of the current navigation state. When routes are removed from that navigation state, `Transitioner` will coordinate the transition away from those routes, keeping them on screen even though they are gone from the navigation state.\n\n\n## Example\n\n```jsx\nclass MyNavView extends Component {\n  ...\n  render() {\n    return (\n      <Transitioner\n        configureTransition={this._configureTransition}\n        navigation={this.props.navigation}\n        render={this._render}\n        onTransitionStart={this.onTransitionStart}\n        onTransitionEnd={this.onTransitionEnd}\n      />\n    );\n}\n```\n\n## Props\n\n### `configureTransition` function\n\nInvoked on `Transitioner.componentWillReceiveProps`, this function allows customization of animation parameters such as `duration`. The value returned from this function will be fed into a timing function, by default `Animated.timing()`, as its config.\n\n#### Examples\n\n```js\n_configureTransition(transitionProps, prevTransitionProps) {\n  return {\n    // duration in milliseconds, default: 250\n    duration: 500,\n    // An easing function from `Easing`, default: Easing.inOut(Easing.ease)\n    easing: Easing.bounce,\n  }\n}\n```\n\nNote: `duration` and `easing` are only applicable when the timing function is `Animated.timing`. We can also use a different timing function and its corresponding config parameters, like so:\n\n```js\n_configureTransition(transitionProps, prevTransitionProps) {\n  return {\n    // A timing function, default: Animated.timing.\n    timing: Animated.spring,\n    // Some parameters relevant to Animated.spring\n    friction: 1,\n    tension: 0.5,\n  }\n}\n```\n\n#### Flow definition\n\n```js\n  configureTransition: (\n    transitionProps: NavigationTransitionProps,\n    prevTransitionProps: ?NavigationTransitionProps,\n  ) => NavigationTransitionSpec,\n```\n\n#### Parameters\n- `transitionProps`: the current [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the current navigation state and props\n- `prevTransitionProps`: the previous [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the previous navigation state and props\n\n#### Returns\n- An object of type [NavigationTransitionSpec](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L316) that will be fed into an Animated timing function as its config\n\n\n### `navigation` prop\nAn object with `state` that represents the navigation state, with `routes` and an active route `index`. Also includes `dispatch` and other methods for requesting actions.\n\n#### Example value\n\n```js\n{\n   // Index refers to the active child route in the routes array.\n  index: 1,\n  routes: [\n    { key: 'DF2FGWGAS-12', routeName: 'ContactHome' },\n    { key: 'DF2FGWGAS-13', routeName: 'ContactDetail', params: { personId: 123 } }\n  ]\n}\n```\n\n#### Flow definition\n```js\nexport type NavigationState = {\n  index: number,\n  routes: Array<NavigationRoute>,\n};\n```\n\nFor more information about the `NavigationRoute` type, check out its [flow definition](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L32).\n\n### `render` function\nInvoked from `Transitioner.render()`. This function performs the actual rendering delegated from `Transitioner`. In this function, we can use the information included in the `transitionProps` and `prevTransitionProps` parameters to render scenes, create animations and handle gestures.\n\nThere are a few important properties of the `transitionProps` and `prevTransitionProps` parameters that are useful for the tasks mentioned above:\n\n- `scenes: Array<NavigationScene>` - a list of all available scenes\n- `position: NavigationAnimatedValue` - the progressive index of the transitioner's navigation state\n- `progress: NavigationAnimatedValue` - the value that represents the progress of the transition when navigation state changes from one to another. Its numeric value will range from 0 to 1.\n\nFor the complete list of properties of `NavigationTransitionProps`, check out its [flow definition](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273).\n\n#### Examples\n\n`transitionProps.scenes` is the list of all available scenes. It is up to the implementor to determine how to lay them out on the screen. For example, we can render the scenes as a stack of cards like so:\n\n```jsx\n_render(transitionProps, prevTransitionProps) {\n  const scenes = transitionProps.scenes.map(scene => this._renderScene(transitionProps, scene));\n  return (\n    <View style={styles.stack}>\n      {scenes}\n    </View>\n  );\n}\n```\n\nWe can then use an `Animated.View` to animate the transition. To create necessary animated style properties, such as `opacity`, we can interpolate on `position` and `progress` values that come with `transitionProps`:\n\n```jsx\n_renderScene(transitionProps, scene) {\n  const { position } = transitionProps;\n  const { index } = scene;\n  const opacity = position.interpolate({\n    inputRange: [index-1, index, index+1],\n    outputRange: [0, 1, 0],\n  });\n  // The prop `router` is populated when we call `createNavigator`.\n  const Scene = this.props.router.getComponent(scene.route.routeName);\n  return (\n    <Animated.View style={{ opacity }}>\n      { Scene }\n    </Animated.View>\n  )\n}\n```\n\nThe above code creates a cross fade animation during transition.\n\nFor a comprehensive tutorial on how to create custom transitions, see this [blog post](http://www.reactnativediary.com/2016/12/20/navigation-experimental-custom-transition-1.html).\n\n#### Flow definition\n```js\nrender: (transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps) => React.Node,\n```\n\n#### Parameters\n- `transitionProps`: the current [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the current state and props\n- `prevTransitionProps`: the previous [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the previous state and props\n\n#### Returns\n- A ReactElement, which will be used to render the Transitioner component\n\n### `onTransitionStart` function\nInvoked when the transition animation is about to start.\n\nIf you return a promise from `onTransitionStart`, the transition animation will begin after the promise is resolved.\n\n#### Flow definition\n```js\nonTransitionStart: (transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps) => (Promise | void),\n```\n#### Parameters\n- `transitionProps`: the current [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the current state and props\n- `prevTransitionProps`: the previous [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the previous state and props\n\n#### Returns\n- `Promise` to delay the start of the transition animation, or none to begin the transition animation immediately.\n\n### `onTransitionEnd` function\nInvoked once the transition animation completes.\n\nIf you return a promise from `onTransitionEnd`, any queued transition animations will begin after the promise is resolved.\n\n#### Flow definition\n```js\nonTransitionEnd: () => void\n```\n#### Parameters\n- none.\n\n#### Returns\n- none.\n","api/views/Views":"# Views\n\nNavigation views are presentation components that take a [`router`](/docs/api/routers) and a [`navigation`](/docs/navigators/navigation-prop) prop, and can display several screens, as specified by the `navigation.state`.\n\nNavigation views are controlled React components that can present the current navigation state. They manage switching of screens, animations and gestures. They also present persistent navigation views such as tab bars and headers.\n\n## Built in Views\n\n- [CardStack](https://github.com/react-community/react-navigation/blob/master/src/views/CardStack/CardStack.js) - Present a stack that looks suitable on any platform\n    + [Card](https://github.com/react-community/react-navigation/blob/master/src/views/CardStack/Card.js) - Present one card from the card stack, with gestures\n    + [Header](https://github.com/react-community/react-navigation/blob/master/src/views/Header/Header.js) - The header view for the card stack\n- [Tabs](https://github.com/react-community/react-navigation/blob/master/src/views/TabView/TabView.js) - A configurable tab switcher / pager\n- [Drawer](https://github.com/react-community/react-navigation/blob/master/src/views/Drawer/DrawerView.js) - A view with a drawer that slides from the left\n\n\n## [Transitioner](/docs/views/transitioner)\n\n`Transitioner` manages the animations during the transition and can be used to build fully custom navigation views. It is used inside the `CardStack` view. [Learn more about Transitioner here.](/docs/views/transitioner)\n","api/withNavigation":"\n# withNavigation\n\n[`withNavigation`](/src/views/withNavigation.js) is a Higher Order Component which passes the `navigation` prop into a wrapped Component. It's useful when you cannot pass the `navigation` prop into the component directly, or don't want to pass it in case of a deeply nested child.\n\n## Example\n\n```js\nimport { Button } 'react-native';\nimport { withNavigation } from 'react-navigation';\n\nconst MyComponent = ({ to, navigation }) => (\n    <Button title={`navigate to ${to}`} onPress={() => navigation.navigate(to)} />\n);\n\nconst MyComponentWithNavigation = withNavigation(MyComponent);\n\n\n// or use decorators:\n\n@withNavigation\nexport default class MainScreen extends Component {\n  ...\n}\n```\n","blog/2017-01-Introducing-React-Navigation":"# Introducing React Navigation for React Native\n_January 26, 2017_\n\nToday we're excited to introduce React Navigation, a flexible navigation library for React Native and web, including customizable views for React Native, routers for any platform, and navigators that make it super easy to get started. We aim to provide a simple and extensible solution which enables developers to share one navigation paradigm for all of their React apps.\n\n\n## Start Quick with pre-built Navigators\n\nA navigator is a React component with a static `.router` declared on it. To make it super easy to get started, React Navigation ships with a few navigator factories, pairing common views with routers.\n\nFor example, the provided `StackNavigator` makes it easy to use a `CardStack` view and a `StackRouter` together:\n\n```js\nconst MyApp = StackNavigator({\n  Home: {screen: HomeScreen},\n  Profile: {screen: ProfileScreen},\n});\n```\n\nEach of these screens are just React components, and they can easily set their own title:\n\n```js\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Home',\n  };\n  render() {\n    const { navigate } = this.props.navigation;\n    return (\n      <Button\n        onPress={() => navigate('Profile', { name: 'A' })}\n        title=\"Go to A's profile\"\n      />\n    );\n  }\n}\n```\n\nTo learn more, [continue with the getting started guide](/docs/intro).\n\n\n## Performant Views on React Native\n\nAnimations and gestures are critical for smooth navigation in a mobile app. React Navigation utilizes React Native's Animated library to provide 60fps animations that are driven from the native thread.\n\nThe views are designed to be highly extensible. For your app, you may want to build a custom modal, fork the stack header, or even utilize the underlying `<Transitioner>` component to build an entirely custom navigation presentation.\n\n\n## Routers for Every Platform\n\nIn React Navigation, routers manage the [relationship between actions, state, and URIs](/docs/routers/api). The routers are cross-platform, and there is example code for iOS, Android, and web. Several routers are included, including [`TabRouter`](/docs/routers/tab) and [`StackRouter`](/docs/routers/stack), and it is encouraged to [override their behavior as needed](/docs/routers).\n\nThe routers are composable and can be useful for structuring your app. A common navigation structure in iOS is to have an independent navigation stack for each tab, where all tabs can be covered by a modal. This is three layers of router: a card stack, within tabs, all within a modal stack. So unlike our experience on web apps, the navigation state of mobile apps is too complex to encode into a single URI. Routers in `react-navigation` map from URIs to navigation actions, which are then used to compute navigation state.\n\n\n## Future\n\nReact Navigation is born from the React Native community's need for an extensible yet easy-to-use navigation solution. It replaces and improves upon several navigation libraries in the ecosystem, including Ex-Navigation and React Native's Navigator and NavigationExperimental components.\n\nUntil the community lands on one navigation solution that works well on the web and React Native, we will forever be destined to re-invent navigation. We are extremely sensitive about the burden of change that accompanies a new navigation library, so we aim to provide a solution that will work long into the future. We are excited to support React Navigation for any platform, including cutting-edge frontiers like hybrid native apps, web server rendering, and ReactVR.\n\nThe first beta of React Navigation is available today on npm and GitHub, and you can [get started here](/docs/intro). We're excited to hear feedback from the React community, and together we still have a long way to go before our dream is realized. We'd love to see the community flourish with beautiful navigation views, custom router integrations, and more easy-to-use navigators. All of these individual contributions can work together seamlessly. If you have improvements for the built-in components, please [follow the contributors guide](/docs/guides/contributors) and dive right in!\n","blog/2017-04-On-the-path-to-v1":"# On the path to React Navigation v1\n\n*April 26, 2017*\n\nWhen we announced React Navigation earlier this year, the core team was blown away at the community's overwhelming excitement and support for the new project. Since the launch in late January, hundreds of contributors have sprung up, reported detailed issues, and committed important fixes to the library.\n\nWith several community members preparing to put apps in production, the highest priority for the core team is to refine the final v1 API, and stabilize it to make sure your apps feel rock-soild.\n\nToday we're excited to announce the release of [beta 9](https://github.com/react-community/react-navigation/releases/tag/v1.0.0-beta.9), which iterates upon the initial API. Although you will need to modify your screen navigation options for this upgrade, we are very confident in the new API. Our goal for future v1 releases is to avoid making any breaking API changes - we are now focused on filling in essential missing features, and stabilization.\n\nThe community has experienced some thrash by a few of our earlier beta releases. So, starting with [this release](https://github.com/react-community/react-navigation/releases/tag/v1.0.0-beta.9), we will include detailed [release notes](https://github.com/react-community/react-navigation/releases) about any API changes, new features, and bug fixes.\n\nAfter the stabilization and release of v1, we're excited to explore new ways of customizing transitions, and overriding navigation components. There are some [exciting proposals](https://github.com/react-community/react-navigation/issues/1263) about these new APIs, and we look forward to the community's feedback and involvement.\n","blog/2017-09-Renewed-v1":"# A (Renewed) Path to React Navigation V1\n\n*September 12, 2017*\n\nIt‚Äôs been awhile since the last post on this blog and I wanted to take a moment to bring everyone up to speed on what‚Äôs been going on with React Navigation.\n\nThis project got big really fast: as the officially recommended navigation library for React Native, thousands of developers are using the project every day to build apps.\n\nHaving such a broad usage, the repository has a lot of new questions, feature requests, and (as with any library) bugs. It‚Äôs gotten a bit out of hand (thus hard to manage) so I wanted to give you an overview of how we‚Äôre trying to get things moving forward again resulting in a stable V1 release.\n\n## Issues\n\nIf you've looked at the project over the last few months you've probably seen that there are a lot of open issues. If you've looked closely over the last few weeks you may have noticed that it's a few hundred less - [progress](https://github.com/react-community/react-navigation/pulse/monthly)!\n\nI wanted to tell you about how we‚Äôre addressing the GitHub issues: in an effort to reduce the cognitive load associated with so many open issues we've set out to accomplish a few things:\n\n1. Label all issues\n2. Close any \"question\" type issues. The idea here is to keep GitHub issues focused on bugs & feature requests. [StackOverflow](https://stackoverflow.com/questions/tagged/react-navigation) and [Reactiflux](https://www.reactiflux.com/) are better places for questions.\n3. Eliminate duplicate issues\n4. Of the remaining issues determine bugs & features necessary for V1\n\nDon't hesitate to open new issues but **please do follow** the issue template! üòÑ\n\n## Pull Requests\n\nWe greatly appreciate all the time put into each and every one of them but, as with issues, there's a bit of a backlog to work through.\n\nWe encourage PRs but we want you to know that we‚Äôre prioritizing bug fixes and feature requests that align with the new 1.0 roadmap (see next section). We want to focus on the highest impact features for the community as a whole.\n\n## A New Roadmap\n\nWe‚Äôre happy to say we‚Äôve put together a new roadmap to version 1.0 of this package! You can see what will be included by checking out [this issue](https://github.com/react-community/react-navigation/issues/2585).\n\nHow do we decide on what to include in the revised V1.0?\n\nWe had conversations with people using React Navigation in production, looked at issues with the most reactions, reviewed high quality pull requests, and talked with the community to see what was needed.\n\nWill V1.0 cover everyone‚Äôs uses? No. But it should cover most use cases and we hope to improve documentation enough that you‚Äôre comfortable and able to customize React Navigation to your needs.\n\n## Roles & Responsibilities\n\nJust like any other organization - no one person can do everything. It‚Äôs helpful to have defined roles & responsibilities so that others know who to ask and we can avoid becoming overwhelmed.\n\nThis is something I want to adopt for the management of React Navigation. I hope it reduces the likelihood of burnout for those that have chosen to dedicate time to the project. With that in mind here are the roles a few primary contributors have chosen to take on:\n\n- [davepack](https://github.com/davepack) - Pull request review, development\n- [GantMan](https://github.com/GantMan) - Issue management, testing\n- [kelset](https://github.com/kelset) - Issue management, pull request review\n- [matthamil](https://github.com/matthamil) - Pull request review, issue management\n- [skevy](https://github.com/skevy) - Pull request review, release management\n- [spencercarli](https://github.com/spencercarli) - Documentation, issue management\n\n[Expo](https://expo.io/) has expressed that React Navigation V1.0 is a priority for them and has committed one of their engineers (Dave) to aid in that.\n\n## The Community Navigation Library\n\nReact Navigation is the React Native community‚Äôs navigation library with that being said - you too can contribute!\n\nIf you see someone's question - try to answer it!\nIf you have thoughts on a potential API for a requested feature - share it!\nIf you think you know the cause for a bug - explain it!\n\nRegardless of what you do though, be nice & remember that on the other side of the screen there is another developer, just like you‚Ä¶\n\nPersonally, I [enjoy some shade](https://media.giphy.com/media/l4FGlDsvuUd2RkBYQ/giphy.gif) thrown my way, but I might be in the minority üòâ.\n\nThanks for reading and I look forward to working with you on React Navigation!\n\nSpencer Carli\n\n*Thanks to Matt Hamill & Lorenzo Sciandra for reviewing.*\n","guides/Common-Navigation-Spec":"# Common Navigation Spec\n\n### Introduction\n\nIt is useful to have ‚Äúone standard way‚Äù to handle navigation in a React app. Unfortunately, we've learned that a single navigation library cannot be the right fit for every application. There is often a tradeoff between several useful features:\n\n* Simplicity\n* Supporting complex animations\n* Navigating between natively-implemented screens and JavaScript screens\n* Precise fidelity to the native UI controls\n* Default support for deep linking and the Android back button\n\nAlthough the React Native community will need more than one navigation library, we can make them work nicely together. The goal of this document is to specify a common API for navigation libraries. Consistency will make several things easier for React Native developers:\n\n* Combining multiple navigation libraries in one application\n* Switching out navigation libraries when requirements change\n* Learning navigation once, and applying that knowledge in different applications\n\nNavigation libraries don't have to implement all of this API - it's just a recommendation.\n\n(TODO: When we actually publish this spec, we should mention here what libraries are supporting it, what libraries will support it, and (link to?) how to migrate from other now-discouraged navigation libraries.)\n\n\n## Key Concepts\n\n#### Navigation Container\n\nThe parent component which hosts a navigation-aware component. It must provide the `navigation` prop, and usually uses the child component's static `router` to determine navigation state.\n\n#### Navigation-Aware Component\n\nA React component which can observe and initiate navigation in an app. It uses the navigation prop to see navigation state and request actions. It may expose a router to define navigation state and URI handling.\n\nThe card stack of your application may be a navigation-aware component. Also, one screen of your app that handles the Android back button is a navigation-aware component.\n\n#### Navigation State\n\nThe object that defines the navigation state of your component, passed in as a prop. A router can define the state, which optionally specifies the title and URI of the component.\n\n#### Action\n\nA JSON object used to request changes in the app's navigation state.\n\n#### Router\n\nDefines the navigation behavior of a component by defining navigation state as a function of actions, and allows URIs to be optionally converted into an action that can be handled.\n\n#### Navigator\n\nA navigation-aware component that hosts other navigation-aware components. Most navigators are expected to delegate all router logic, manage child navigation state, and pass up actions as they are dispatched.\n\n## Specification\n\n### The `navigation` prop\n\nThe navigation prop should be provided to components who need access to navigation. If provided, it must follow this interface:\n\n```javascript\ntype BackAction = {type: 'Navigation/BACK'};\ntype URIAction = {type: 'Navigation/URI', uri: string};\n\ninterface Navigation<S, A> {\n  dispatch(action: (A | BackAction | URIAction)): boolean;\n  state: S;\n}\n```\n\n#### navigation.state\n\nThe controlled navigation state prop, as requested by the parent.\n\n```javascript\nconst MyView = ({ navigation }) => {\n  switch (navigation.state.myRequestedView) {\n    case 'ViewA': return <ViewA />;\n    case 'ViewB': return <ViewB />;\n    default: return <OtherView />;\n  }\n}\n```\n\n#### navigation.dispatch(action)\n\nThe channel that a component can call to request navigation from its parent. When calling `dispatch`, you must provide an action object with a `type`. There are two special action types: 'Navigation/BACK' and 'Navigation/URI'.\n\n```javascript\nconst MyLink = ({ navigation }) => (\n  <Button onPress={() => {\n    navigation.dispatch({\n      type: 'MyNavigationRequest',\n      myParam: 42,\n    });\n  }>\n    Press me to navigate\n  </Button>\n);\n```\n\n\n### The static `router`\n\nA router object may be statically defined on your component. If defined, it must follow this interface:\n\n```javascript\ntype BackAction = {type: 'Navigation/BACK'};\ntype URIAction = {type: 'Navigation/URI', uri: string};\n\ninterface Router<S, A> {\n  getStateForAction(action: (A | BackAction | URIAction), lastState: ?S): ?S;\n  getActionForURI(uri: string): ?A;\n}\n```\n\nThe state and action types of the static router must match the state and action types associated with the navigation prop passed into the component.\n\n#### router.getStateForAction(action, lastState)\n\nThis function is defined on the static router and is used to define the expected navigation state.\n\n```javascript\nclass ScreenWithEditMode extends React.Component {\n  static router = {\n    getStateForAction: (action, prevState) => {\n      return { isEditing: true };\n    },\n  };\n  render() {\n    // this.props.navigation.state.isEditing === true\n    ...\n  }\n}\n```\n\n`getStateForAction` must **always** return a navigation state that can be rendered by the component when passed in as the `navigation.state` prop.\n\nIf null is returned, we are signaling that the previous navigation state has not changed, but the action is handled. This is usually used in cases where the action is being swallowed.\n\n\n#### router.getActionForURI(uri)\n\nReturn an action if a URI can be handled, otherwise return `null`\n\n\n\n### Special Actions\n\nThere are two special actions that can be fired into `navigation.dispatch` and can be handled by your `router.getStateForAction`.\n\n#### Back Action\n\nThis action means the same thing as an Android back button press.\n\n```\ntype BackAction = { type: 'Navigation/BACK' };\n```\n\n#### URI Open Action\n\nUsed to request the enclosing app or OS to open a link at a particular URI. If it is a web URI like `http` or `https`, the app may open a WebView to present the page. Or the app may open the URI in a web browser. In some cases, an app may choose to block a URI action or handle it differently.\n\n```\ntype URIAction = { type: 'Navigation/URI', uri: string };\n```\n\n\n### Special Navigation State\n\nThe state defined by `router.getStateForAction` can contain special navigation properties that may be relevant to your app. The title and current URI of a component may change over time, and the parent often needs to observe the behavior.\n\n#### `state.title`\n\nIf the navigation state contains 'title', it will be used as the title for the given component. This is relevant for top-level components on the web to update the browser title, and is relevant in mobile apps where a title is shown in the header.\n\n#### `state.uri`\n\nA URI can also be put in `state.uri`, which will signal to the parent how it may be possible to deep link into a similar navigation state. In web apps, this will be used to keep the URI bar in sync with the current navigation state of the app.\n\n\n## Use Cases\n\n### \"Block the Android back button on one screen of my app\"\n\nTo block the Android back button:\n\n```\nclass Foo extends React.Component {\n  static router = {\n    getStateForAction(action, prevState = {}) {\n      if (action.type === 'Navigation/BACK') return null;\n      else return prevState;\n    },\n  };\n  render() {\n    ...\n```\n\nBecause we return null, we signal to our container that the action has been handled but the state does not change. The parent should not handle the back behavior at this point, and nothing should be re-rendered.\n\n### \"Link deeply into one screen of my app\"\n\n```\nclass Foo extends React.Component {\n  static router = {\n    getStateForAction(action, prevState = {deep: false}) {\n      if (action.type === 'GoDeep') return { deep: true };\n      else return prevState;\n    },\n    getActionForURI(uri) {\n      if (uri === 'myapp://foo')\n        return {type: 'Go'};\n      else if (uri === 'myapp://foo_deep')\n        return {type: 'GoDeep'};\n      return null;\n    },\n  };\n  render() {\n    // this.props.navigation.state.deep may be true or false\n    ...\n```\n\nBased on the state URI we may decide to return an action. If an action is returned, `getStateForAction` is expected to output the correct state for a deep link.\n\n## Reference Implementations\n\nA library to that helps easily produce navigation-aware components: https://github.com/react-community/react-navigation . (Also uses a HOC to provide navigation containers when needed.)\n\nA simple navigation container: https://gist.github.com/ericvicenti/77d190e2ec408012255937400e34bdb1\n\nA web implementation of a navigation container: https://gist.github.com/ericvicenti/55bef95fcd8558029a3bae8483baea6c\n","guides/Custom-Navigators":"# Custom Navigators\n\nA navigator is any React component that has a [router](/docs/routers/) on it. Here is a basic one, which uses the [router's API](/docs/routers/api) to get the active component to render:\n\n```js\nclass MyNavigator extends React.Component {\n  static router = MyRouter;\n  render() {\n    const { state, dispatch } = this.props.navigation;\n    const { routes, index } = state;\n\n    // Figure out what to render based on the navigation state and the router:\n    const Component = MyRouter.getComponentForState(state);\n\n    // The state of the active child screen can be found at routes[index]\n    let childNavigation = { dispatch, state: routes[index] };\n    // If we want, we can also tinker with the dispatch function here, to limit\n    // or augment our children's actions\n\n    // Assuming our children want the convenience of calling .navigate() and so on,\n    // we should call addNavigationHelpers to augment our navigation prop:\n    childNavigation = addNavigationHelpers(childNavigation);\n\n    return <Component navigation={childNavigation} />;\n  }\n}\n```\n\n## Navigation Prop\n\nThe navigation prop passed down to a navigator only includes `state` and `dispatch`. This is the current state of the navigator, and an event channel to send action requests.\n\nAll navigators are controlled components: they always display what is coming in through `props.navigation.state`, and their only way to change the state is to send actions into `props.navigation.dispatch`.\n\nNavigators can specify custom behavior to parent navigators by [customizing their router](/docs/routers/). For example, a navigator is able to specify when actions should be blocked by returning null from `router.getStateForAction`. Or a navigator can specify custom URI handling by overriding `router.getActionForPathAndParams` to output a relevant navigation action, and handling that action in `router.getStateForAction`.\n\n### Navigation State\n\nThe navigation state that is passed into a navigator's `props.navigation.state` has the following structure:\n\n```\n{\n  index: 1, // identifies which route in the routes array is active\n  routes: [\n    {\n      // Each route needs a name, which routers will use to associate each route\n      // with a react component\n      routeName: 'MyRouteName',\n\n      // A unique id for this route, used to keep order in the routes array:\n      key: 'myroute-123',\n\n      // Routes can have any additional data. The included routers have `params`\n      ...customRouteData,\n    },\n    ...moreRoutes,\n  ]\n}\n```\n\n### Navigation Dispatchers\n\nA navigator can dispatch navigation actions, such as 'Go to a URI', 'Go back'.\n\nThe dispatcher will return `true` if the action was successfully handled, otherwise `false`.\n\n## API for building custom navigators\n\nTo help developers implement custom navigators, the following utilities are provided with React Navigation:\n\n### `createNavigator`\n\nThis utility combines a [router](/docs/routers/) and a [navigation view](/docs/views/) together in a standard way:\n\n```js\nconst MyApp = createNavigator(MyRouter)(MyView);\n```\n\nAll this does behind the scenes is:\n\n```js\nconst MyApp = ({ navigation }) => (\n  <MyView router={MyRouter} navigation={navigation} />\n);\nMyApp.router = MyRouter;\n```\n\n### `addNavigationHelpers`\n\nTakes in a bare navigator navigation prop with `state` and `dispatch`, and augments it with all the various functions in a screen navigation prop, such as `navigation.navigate()` and `navigation.goBack()`. These functions are simply helpers to create the actions and send them into `dispatch`.\n\n### `createNavigationContainer`\n\nIf you want your navigator to be usable as a top-level component, (without a navigation prop being passed in), you can use `createNavigationContainer`. This utility will make your navigator act like a top-level navigator when the navigation prop is missing. It will manage the app state, and integrate with app-level nav features, like handling incoming and outgoing links, and Android back button behavior.\n","guides/Customizing-Navigation":"## Customizing Navigation Views\n\nModify the presentation of navigation, including styles, animations and gestures.\n\n## Customizing Routers\n\nBuilding a custom router allows you to change the navigation logic of your component, manage navigation state, and define behavior for URIs.\n\n\nA router can be defined like this:\n\n```js\nclass MyNavigationAwareComponent extends React.Component {\n\n    static router = {\n\n        // Defines the navigation state for a component:\n        getStateForAction: (action: {type: string}, lastState?: any) => {\n            const state = lastState = { myMode: 'default' };\n            if (action.type === 'MyAction') {\n                return { myMode: 'action' };\n            } else if (action.type === NavigationActions.BACK) {\n                return { myMode: 'blockBackButton' };\n            } else {\n                return state;\n            }\n        },\n\n        // Defines if a component can handle a particular URI.\n        // If it does, return an action to be passed to `getStateForAction`\n\n        getActionForURI: (uri: string) => {\n            if (uri === 'myapp://myAction') {\n                return { type: 'MyAction' };\n            }\n            return null;\n        },\n\n    };\n\n    render() {\n        // render something based on this.props.navigation.state\n        ...\n    }\n\n    onButtonPress = () => {\n        this.props.navigation.dispatch({ type: 'MyAction' });\n    };\n\n    ...\n\n}\n```\n","guides/Deep-Linking":"# Deep Linking\n\nIn this guide we will set up our app to handle external URIs. Let's start with the SimpleApp that [we created in the getting started guide](/docs/intro).\n\nIn this example, we want a URI like `mychat://chat/Taylor` to open our app and link straight into Taylor's chat page.\n\n## Configuration\n\nPreviously, we had defined a navigator like this:\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Chat: { screen: ChatScreen },\n});\n```\n\nWe want paths like `chat/Taylor` to link to a \"Chat\" screen with the `user` passed as a param. Let's re-configure our chat screen with a `path` that tells the router what relative path to match against, and what params to extract. This path spec would be `chat/:user`.\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Chat: {\n    screen: ChatScreen,\n    path: 'chat/:user',\n  },\n});\n```\n\n\n### URI Prefix\n\nNext, let's configure our navigation container to extract the path from the app's incoming URI. \n\n```js\nconst SimpleApp = StackNavigator({...});\n\n// on Android, the URI prefix typically contains a host in addition to scheme\nconst prefix = Platform.OS == 'android' ? 'mychat://mychat/' : 'mychat://';\n\nconst MainApp = () => <SimpleApp uriPrefix={prefix} />;\n```\n\n## iOS\n\nLet's configure the native iOS app to open based on the `mychat://` URI scheme.\n\nIn `SimpleApp/ios/SimpleApp/AppDelegate.m`:\n\n```\n// Add the header at the top of the file:\n#import <React/RCTLinkingManager.h>\n\n// Add this above the `@end`:\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url\n  sourceApplication:(NSString *)sourceApplication annotation:(id)annotation\n{\n  return [RCTLinkingManager application:application openURL:url\n                      sourceApplication:sourceApplication annotation:annotation];\n}\n```\n\nIn Xcode, open the project at `SimpleApp/ios/SimpleApp.xcodeproj`. Select the project in sidebar and navigate to the info tab. Scroll down to \"URL Types\" and add one. In the new URL type, set the identifier and the url scheme to your desired url scheme.\n\n![Xcode project info URL types with mychat added](/assets/xcode-linking.png)\n\nNow you can press play in Xcode, or re-build on the command line:\n\n```sh\nreact-native run-ios\n```\n\nTo test the URI on the simulator, run the following:\n\n```\nxcrun simctl openurl booted mychat://chat/Taylor\n```\n\nTo test the URI on a real device, open Safari and type `mychat://chat/Taylor`.\n\n## Android\n\nTo configure the external linking in Android, you can create a new intent in the manifest.\n\nIn `SimpleApp/android/app/src/main/AndroidManifest.xml`, add the new `VIEW` type `intent-filter` inside the `MainActivity` entry:\n\n```\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:scheme=\"mychat\"\n          android:host=\"mychat\" />\n</intent-filter>\n```\n\nNow, re-install the app:\n\n```sh\nreact-native run-android\n```\n\nTo test the intent handling in Android, run the following:\n\n```\nadb shell am start -W -a android.intent.action.VIEW -d \"mychat://mychat/chat/Taylor\" com.simpleapp\n```\n\n```phone-example\nlinking\n```\n","guides/Guide-Basic-Example":"# Hello Mobile Navigation\n\nLet's use React Navigation to build a simple chat-like application for Android and iOS.\n\n## Setup and Installation\n\nFirst, make sure you're [all set up to use React Native](http://facebook.github.io/react-native/docs/getting-started.html). Next, create a new project and add `react-navigation`:\n\n```sh\n# Create a new React Native App\nreact-native init SimpleApp\ncd SimpleApp\n\n# Install the latest version of react-navigation from npm\nnpm install --save react-navigation\n\n# Run the new app\nreact-native run-android\n# or:\nreact-native run-ios\n```\n\nIf you are using `create-react-native-app` instead of `react-native init`, then:\n\n```sh\n# Create a new React Native App\ncreate-react-native-app SimpleApp\ncd SimpleApp\n\n# Install the latest version of react-navigation from npm\nnpm install --save react-navigation\n\n# Run the new app\nnpm start\n\n# This will start a development server for you and print a QR code in your terminal.\n```\n\nVerify that you can successfully see the bare sample app run on iOS and/or Android:\n\n```phone-example\nbare-project\n```\n\nWe want to share code on iOS and Android, so let's delete the contents of `index.js` (or `index.ios.js` and `index.android.js` if using a React Native version before 0.49) and replace it with `import './App';` - after which, we need to create the new file for our app implementation, `App.js` (if you used `create-react-native-app` this has been already done)\n\n## Introducing Stack Navigator\n\nFor our app, we want to use the `StackNavigator` because conceptually we want to obtain a 'card stack' effect of movement, where each new screen is put on the top of the stack and going back removes a screen from the top of the stack. Let's start with just one screen:\n\n```js\nimport React from 'react';\nimport {\n  AppRegistry,\n  Text,\n} from 'react-native';\nimport { StackNavigator } from 'react-navigation';\n\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Welcome',\n  };\n  render() {\n    return <Text>Hello, Navigation!</Text>;\n  }\n}\n\nexport const SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen },\n});\n\nAppRegistry.registerComponent('SimpleApp', () => SimpleApp);\n```\n\nIf you used `create-react-native-app` the already existing `App.js` will be modified to\n\n```js\nimport React from 'react';\nimport { StyleSheet, Text, View } from 'react-native';\nimport { StackNavigator } from 'react-navigation';\n\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Welcome'\n  };\n  render() {\n    return <Text>Hello, Navigation!</Text>;\n  }\n}\n\nconst SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen }\n});\n\nexport default class App extends React.Component {\n  render() {\n    return <SimpleApp />;\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n    alignItems: 'center',\n    justifyContent: 'center'\n  }\n});\n\n```\n\nThe `title` of the screen is configurable on the [static `navigationOptions`](/docs/navigators/navigation-options), where many options can be set to configure the presentation of the screen in the navigator.\n\nNow the same screen should appear on both iPhone and Android apps:\n\n```phone-example\nfirst-screen\n```\n\n## Adding a New Screen\n\nIn our `App.js` file, let's add a new screen called `ChatScreen`, defining it under `HomeScreen`:\n\n```js\n// ...\n\nclass HomeScreen extends React.Component {\n    //...\n}\n\nclass ChatScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Chat with Lucy',\n  };\n  render() {\n    return (\n      <View>\n        <Text>Chat with Lucy</Text>\n      </View>\n    );\n  }\n}\n\n```\n\nWe can then add a button to our `HomeScreen` component that links to `ChatScreen`: we need to use the provided method `navigate` (from the [screen navigation prop](/docs/navigators/navigation-prop)) by giving it the `routeName` of the screen we want to reach, in this case `Chat`.\n\n```js\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Welcome',\n  };\n  render() {\n    const { navigate } = this.props.navigation;\n    return (\n      <View>\n        <Text>Hello, Chat App!</Text>\n        <Button\n          onPress={() => navigate('Chat')}\n          title=\"Chat with Lucy\"\n        />\n      </View>\n    );\n  }\n}\n```\n\n(*don't forget to import View and Button from react-native:* `import { AppRegistry, Text, View, Button } from 'react-native';`)\n\nBut that won't work until we say to our `StackNavigator` of the existence of the `Chat` screen, like so:\n\n```js\nexport const SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Chat: { screen: ChatScreen },\n});\n```\n\nNow you can navigate to your new screen, and go back:\n\n```phone-example\nfirst-navigation\n```\n\n## Passing params\n\nHardcoding a name into the `ChatScreen` isn't ideal. It'd be more useful if we could pass a name to be rendered instead, so let's do that.\n\nIn addition to specifying the target `routeName` in the navigate function, we can pass params that will be put into the new route. First, we'll edit our `HomeScreen` component to pass a `user` param into the route.\n\n```js\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Welcome',\n  };\n  render() {\n    const { navigate } = this.props.navigation;\n    return (\n      <View>\n        <Text>Hello, Chat App!</Text>\n        <Button\n          onPress={() => navigate('Chat', { user: 'Lucy' })}\n          title=\"Chat with Lucy\"\n        />\n      </View>\n    );\n  }\n}\n```\n\nWe can then edit our `ChatScreen` component to display the `user` param that was passed in through the route:\n\n```js\nclass ChatScreen extends React.Component {\n  // Nav options can be defined as a function of the screen's props:\n  static navigationOptions = ({ navigation }) => ({\n    title: `Chat with ${navigation.state.params.user}`,\n  });\n  render() {\n    // The screen's current route is passed in to `props.navigation.state`:\n    const { params } = this.props.navigation.state;\n    return (\n      <View>\n        <Text>Chat with {params.user}</Text>\n      </View>\n    );\n  }\n}\n```\n\nNow you can see the name when you navigate to the Chat screen. Try changing the `user` param in `HomeScreen` and see what happens!\n\n```phone-example\nfirst-navigation\n```\n","guides/Guide-Headers":"# Configuring the Header\n\nHeader is only available for StackNavigator.\n\nIn the previous example, we created a StackNavigator to display several screens in our app.\n\n\nWhen navigating to a chat screen, we can specify params for the new route by providing them to the navigate function. In this case, we want to provide the name of the person on the chat screen:\n\n```js\nthis.props.navigation.navigate('Chat', { user:  'Lucy' });\n```\n\nThe `user` param can be accessed from the chat screen:\n\n```js\nclass ChatScreen extends React.Component {\n  render() {\n    const { params } = this.props.navigation.state;\n    return <Text>Chat with {params.user}</Text>;\n  }\n}\n```\n\n### Setting the Header Title\n\nNext, the header title can be configured to use the screen param:\n\n```js\nclass ChatScreen extends React.Component {\n  static navigationOptions = ({ navigation }) => ({\n    title: `Chat with ${navigation.state.params.user}`,\n  });\n  ...\n}\n```\n\n```phone-example\nbasic-header\n```\n\n\n### Adding a Right Button\n\nThen we can add a [`header` navigation option](/docs/navigators/navigation-options#Stack-Navigation-Options) that allows us to add a custom right button:\n\n```js\nstatic navigationOptions = {\n  headerRight: <Button title=\"Info\" />,\n  ...\n```\n\n```phone-example\nheader-button\n```\n\nThe navigation options can be defined with a [navigation prop](/docs/navigators/navigation-prop). Let's render a different button based on the route params, and set up the button to call `navigation.setParams` when pressed.\n\n```js\nstatic navigationOptions = ({ navigation }) => {\n  const { state, setParams } = navigation;\n  const isInfo = state.params.mode === 'info';\n  const { user } = state.params;\n  return {\n    title: isInfo ? `${user}'s Contact Info` : `Chat with ${state.params.user}`,\n    headerRight: (\n      <Button\n        title={isInfo ? 'Done' : `${user}'s info`}\n        onPress={() => setParams({ mode: isInfo ? 'none' : 'info' })}\n      />\n    ),\n  };\n};\n```\n\nNow, the header can interact with the screen route/state:\n\n```phone-example\nheader-interaction\n```\n\n### Header interaction with screen component\n\nSometimes it is necessary for the header to access properties of the screen component such as functions or state.\n\nLet's say we want to create an 'edit contact info' screen with a save button in the header. We want the save button to be replaced by an `ActivityIndicator` while saving.\n\n```js\nclass EditInfoScreen extends React.Component {\n  static navigationOptions = ({ navigation }) => {\n    const { params = {} } = navigation.state;\n    let headerRight = (\n      <Button\n        title=\"Save\"\n        onPress={params.handleSave ? params.handleSave : () => null}\n      />\n    );\n    if (params.isSaving) {\n      headerRight = <ActivityIndicator />;\n    }\n    return { headerRight };\n  };\n\n  state = {\n    nickname: 'Lucy jacuzzi'\n  }\n\n  _handleSave = () => {\n    // Update state, show ActivityIndicator\n    this.props.navigation.setParams({ isSaving: true });\n    \n    // Fictional function to save information in a store somewhere\n    saveInfo().then(() => {\n      this.props.navigation.setParams({ isSaving: false});\n    })\n  }\n\n  componentDidMount() {\n    // We can only set the function after the component has been initialized\n    this.props.navigation.setParams({ handleSave: this._handleSave });\n  }\n\n  render() {\n    return (\n      <TextInput\n        onChangeText={(nickname) => this.setState({ nickname })}\n        placeholder={'Nickname'}\n        value={this.state.nickname}\n      />\n    );\n  }\n}\n```\n\n**Note**: Since the `handleSave`-param is only set on component mount it is not immediately available in the `navigationOptions`-function. Before `handleSave` is set we pass down an empty function to the `Button`-component in order to make it render immediately and avoid flickering.\n\n\nTo see the rest of the header options, see the [navigation options document](/docs/navigators/navigation-options#Stack-Navigation-Options).\n\nAs an alternative to `setParams`, you may want to consider using a state management library such as [MobX](https://github.com/mobxjs/mobx) or [Redux](https://github.com/reactjs/redux), and when navigating to a screen, pass an object which contains the data necessary for the screen to render, as well as functions you may want to call that modify the data, make network requests and etc. That way, both your screen component and the static `navbarOptions` block will have access to the object. When following this approach, make sure to consider deep linking, which works best in cases where only javascript primitives are passed as navigation props to your screen. In case when deep linking is necessary, you may use a [higher order component (HOC)](https://reactjs.org/docs/higher-order-components.html) to transform the primitives to the object your screen components expects.\n","guides/Guide-Intro":"# Introduction\n\n_Learn once, navigate anywhere._\n\nReact Navigation is born from the React Native community's need for an extensible yet easy-to-use navigation solution based on Javascript.\n\nReact Navigation is the result of a collaboration between developers from Facebook, Expo and the React community at large: it replaces and improves upon several navigation libraries in the ecosystem, including Ex-Navigation, React Native's Navigator and NavigationExperimental components.\n\n## Getting Started\n\nIf you're already familiar with React Native then you'll be able to get moving with React Navigation in minimal time.\n\n1. [Quick Start](/docs/intro/quick-start)\nQuickly get a grasp on the React Navigation API with demonstrations of the StackNavigator, TabNavigator, and DrawerNavigator.\n\n2. [Simple App](/docs/intro/basic-app)\nDive into the basics of React Navigation by creating a new React Native project, installing React Navigation, creating your first navigator, and learning how to interact with it.\n\n3. [Navigation Playground](https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground)\nCurious of the various capabilities of React Navigation? Browse the official example app, which will demonstrate various patterns with React Navigation.\n\n4. [Community Contributions](https://github.com/react-community/react-navigation#community-contributions)\nWith the flexibility of React Navigation we won't be able to cover every possible situation, but another developer may have! Browse our list of community contributions to find topics that may answer your questions.\n","guides/Guide-Nested":"# Nesting Navigators\n\nIt is common in mobile apps to compose various forms of navigation. The routers and navigators in React Navigation are composable, which allows you to define a complicated navigation structure for your app.\n\nFor our chat app, we want to put several tabs on the first screen, to view recent chat threads or all contacts.\n\n## Introducing Tab Navigator\n\nLets create a new `TabNavigator` in our `App.js`:\n\n```js\nimport { TabNavigator } from \"react-navigation\";\n\nclass RecentChatsScreen extends React.Component {\n  render() {\n    return <Text>List of recent chats</Text>\n  }\n}\n\nclass AllContactsScreen extends React.Component {\n  render() {\n    return <Text>List of all contacts</Text>\n  }\n}\n\nconst MainScreenNavigator = TabNavigator({\n  Recent: { screen: RecentChatsScreen },\n  All: { screen: AllContactsScreen },\n});\n```\n\nIf the `MainScreenNavigator` was rendered as the top-level navigator component, it would look like this:\n\n```phone-example\nsimple-tabs\n```\n\n\n\n## Nesting a Navigator in a screen\n\nWe want these tabs to be visible in the first screen of the app, but new screens in the stack should cover the tabs.\n\nLets add our tabs navigator as a screen in our top-level `StackNavigator` that we set up in the [previous step](/docs/intro/).\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { screen: MainScreenNavigator },\n  Chat: { screen: ChatScreen },\n});\n```\n\nBecause `MainScreenNavigator` is being used as a screen, we can give it `navigationOptions`:\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { \n    screen: MainScreenNavigator,\n    navigationOptions: {\n      title: 'My Chats',\n    },\n  },\n  Chat: { screen: ChatScreen },\n})\n```\n\nLets also add a button to each tab that links to a chat:\n\n```js\n<Button\n  onPress={() => this.props.navigation.navigate('Chat', { user: 'Lucy' })}\n  title=\"Chat with Lucy\"\n/>\n```\n\nNow we have put one navigator inside another, and we can `navigate` between navigators:\n\n```phone-example\nnested\n```\n\n## Nesting a Navigator in a Component\nSometimes it is desirable to nest a navigator that is wrapped in a component. This is useful in cases where the navigator only takes up part of the screen. For the child navigator to be wired into the navigation tree, it needs the `navigation` property from the parent navigator.\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { screen: NavigatorWrappingScreen },\n  Chat: { screen: ChatScreen },\n});\n```\nIn this case, the NavigatorWrappingScreen is not a navigator, but it renders a navigator as part of its output.\n\nIf this navigator renders blank then change `<View>` to `<View style={{flex: 1}}>`.\n\n```js\nclass NavigatorWrappingScreen extends React.Component {\n  render() {\n    return (\n      <View>\n        <SomeComponent/>\n        <MainScreenNavigator/>\n      </View>\n    );\n  }\n}\n```\n\nTo wire `MainScreenNavigator` into the navigation tree, we assign its `router` to the wrapping component. This makes `NavigatorWrappingScreen` \"navigation aware\", which tells the parent navigator to pass the navigation object down. Since the `NavigatorWrappingScreen`'s `router` is overridden with the child navigator's `router`, the child navigator will receive the needed `navigation`.\n\n```js\nclass NavigatorWrappingScreen extends React.Component {\n  render() {\n    return (\n      <View>\n        <SomeComponent/>\n        <MainScreenNavigator navigation={this.props.navigation}/>\n      </View>\n    );\n  }\n}\nNavigatorWrappingScreen.router = MainScreenNavigator.router;\n```\n","guides/Guide-Quick-Start":"# Quick Start Guide\n\nTo get started with React Navigation, all you have to do is install the `react-navigation` npm package.\n\n### Install with NPM\n\n```\nnpm install --save react-navigation\n```\n\n### Install with Yarn\n\n```\nyarn add react-navigation\n```\n\nTo start using React Navigation you'll have to create a navigator. React Navigation comes with three default navigators.\n\n- `StackNavigator` - Provides a way for your app to transition between screens where each new screen is placed on top of a stack.\n- `TabNavigator` - Used to set up a screen with several tabs.\n- `DrawerNavigator` - Used to set up a screen with drawer navigation.\n\n## Creating a StackNavigator\n\nStackNavigator's are the most common form of navigator so we'll use it as a basic demonstration. To get started, create a `StackNavigator`.\n\n```javascript\nimport { StackNavigator } from 'react-navigation';\n\nconst RootNavigator = StackNavigator({\n\n});\n\nexport default RootNavigator;\n```\n\nWe can then add screens to this `StackNavigator`. Each key represents a screen.\n\n```javascript\nimport React from 'react';\nimport { View, Text } from 'react-native';\nimport { StackNavigator } from 'react-navigation';\n\nconst HomeScreen = () => (\n  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n    <Text>Home Screen</Text>\n  </View>\n);\n\nconst DetailsScreen = () => (\n  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n    <Text>Details Screen</Text>\n  </View>\n);\n\nconst RootNavigator = StackNavigator({\n  Home: {\n    screen: HomeScreen,\n  },\n  Details: {\n    screen: DetailsScreen,\n  },\n});\n\nexport default RootNavigator;\n```\n\nNow let's add a title to the navigation bar.\n\n```javascript\n...\n\nconst RootNavigator = StackNavigator({\n  Home: {\n    screen: HomeScreen,\n    navigationOptions: {\n      headerTitle: 'Home',\n    },\n  },\n  Details: {\n    screen: DetailsScreen,\n    navigationOptions: {\n      headerTitle: 'Details',\n    },\n  },\n});\n\nexport default RootNavigator;\n```\n\nFinally, we should be able to navigate from the home screen to the details screen. When you register a component with a navigator that component will then have a `navigation` prop added to it. This `navigation` prop drives how we move between different screens.\n\nTo move from the home screen to the details screen we'll want to use `navigation.navigate`, like so:\n\n```javascript\n...\nimport { View, Text, Button } from 'react-native';\n\nconst HomeScreen = ({ navigation }) => (\n  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n    <Text>Home Screen</Text>\n    <Button\n      onPress={() => navigation.navigate('Details')}\n      title=\"Go to details\"\n    />\n  </View>\n);\n\n...\n```\n\nAnd there you have it! That's the basics of using the [StackNavigator](/docs/navigators/stack), and React Navigation as a whole. Here's the full code from this example:\n\n<div class=\"snack\" data-snack-id=\"HJlnU0XTb\" data-snack-platform=\"ios\" data-snack-preview=\"true\" data-snack-theme=\"light\" style=\"overflow:hidden;background:#fafafa;border:1px solid rgba(0,0,0,.16);border-radius:4px;height:505px;width:100%\"></div>\n\n## Creating a TabNavigator\n\nTo get started with `TabNavigator` first import and create a new `RootTabs` component.\n\n```javascript\nimport { TabNavigator } from 'react-navigation';\n\nconst RootTabs = TabNavigator({\n\n});\n\nexport default RootTabs;\n```\n\nWe then need to create some screens and add them to our `TabNavigator`.\n\n```javascript\nimport React from 'react';\nimport { View, Text } from 'react-native';\nimport { TabNavigator } from 'react-navigation';\n\nconst HomeScreen = () => (\n  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n    <Text>Home Screen</Text>\n  </View>\n);\n\nconst ProfileScreen = () => (\n  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n    <Text>Profile Screen</Text>\n  </View>\n);\n\nconst RootTabs = TabNavigator({\n  Home: {\n    screen: HomeScreen,\n  },\n  Profile: {\n    screen: ProfileScreen,\n  },\n});\n\nexport default RootTabs;\n```\n\nGetting there! Now let's explicity set a label and icon for the tab bar.\n\n> We'll be using [`react-native-vector-icons`](https://github.com/oblador/react-native-vector-icons) in the example. If you don't have it installed in your project already please do so.\n\n```javascript\n...\nimport Ionicons from 'react-native-vector-icons/Ionicons';\n\n...\n\nconst RootTabs = TabNavigator({\n  Home: {\n    screen: HomeScreen,\n    navigationOptions: {\n      tabBarLabel: 'Home',\n      tabBarIcon: ({ tintColor, focused }) => (\n        <Ionicons\n          name={focused ? 'ios-home' : 'ios-home-outline'}\n          size={26}\n          style={{ color: tintColor }}\n        />\n      ),\n    },\n  },\n  Profile: {\n    screen: ProfileScreen,\n    navigationOptions: {\n      tabBarLabel: 'Profile',\n      tabBarIcon: ({ tintColor, focused }) => (\n        <Ionicons\n          name={focused ? 'ios-person' : 'ios-person-outline'}\n          size={26}\n          style={{ color: tintColor }}\n        />\n      ),\n    },\n  },\n});\n\nexport default RootTabs;\n```\n\nThis will ensure the `tabBarLabel` is consistent (important when using nested navigators) and it will set a `tabBarIcon`. This icon will only be visible on iOS by default given the tab bar component used, which aligns with standard design patterns on Android.\n\nYou can view the complete finished code below:\n\n<div class=\"snack\" data-snack-id=\"BJZ2GVVpb\" data-snack-platform=\"ios\" data-snack-preview=\"true\" data-snack-theme=\"light\" style=\"overflow:hidden;background:#fafafa;border:1px solid rgba(0,0,0,.16);border-radius:4px;height:505px;width:100%\"></div>\n\n## Creating a DrawerNavigator\n\nTo get started with `DrawerNavigator` first import and create a new `RootDrawer` component.\n\n```javascript\nimport { DrawerNavigator } from 'react-navigation';\n\nconst RootDrawer = DrawerNavigator({\n\n});\n\nexport default RootDrawer;\n```\n\nWe then need to create some screens and add them to our `DrawerNavigator`.\n\n```javascript\nimport React from 'react';\nimport { View, Text } from 'react-native';\nimport { DrawerNavigator } from 'react-navigation';\n\nconst HomeScreen = () => (\n  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n    <Text>Home Screen</Text>\n  </View>\n);\n\nconst ProfileScreen = () => (\n  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n    <Text>Profile Screen</Text>\n  </View>\n);\n\nconst RootDrawer = DrawerNavigator({\n  Home: {\n    screen: HomeScreen,\n  },\n  Profile: {\n    screen: ProfileScreen,\n  },\n});\n\nexport default RootDrawer;\n```\n\nGetting there! Now let's explicity set a label and icon for the drawer items.\n\n> We'll be using `react-native-vector-icons` in the example. If you don't have it installed in your project already please do so.\n\n```javascript\n...\nimport Ionicons from 'react-native-vector-icons/Ionicons';\n\n...\n\nconst RootDrawer = DrawerNavigator({\n  Home: {\n    screen: HomeScreen,\n    navigationOptions: {\n      drawerLabel: 'Home',\n      drawerIcon: ({ tintColor, focused }) => (\n        <Ionicons\n          name={focused ? 'ios-home' : 'ios-home-outline'}\n          size={20}\n          style={{ color: tintColor }}\n        />\n      ),\n    },\n  },\n  Profile: {\n    screen: ProfileScreen,\n    navigationOptions: {\n      drawerLabel: 'Profile',\n      drawerIcon: ({ tintColor, focused }) => (\n        <Ionicons\n          name={focused ? 'ios-person' : 'ios-person-outline'}\n          size={20}\n          style={{ color: tintColor }}\n        />\n      ),\n    },\n  },\n});\n\nexport default RootDrawer;\n```\n\nTo open the drawer you can swipe from the left edge of the screen to the right. You've also got the option to open the drawer view `navigation.navigate('DrawerToggle')`, which we'll add to the Home component now. Make sure you import the `Button` component from `react-native`.\n\n```javascript\n...\n\nconst HomeScreen = ({ navigation }) => (\n  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n    <Text>Home Screen</Text>\n    <Button\n      onPress={() => navigation.navigate('DrawerToggle')}\n      title=\"Open Drawer\"\n    />\n  </View>\n);\n\n...\n```\n\nYou can view the finished code below.\n\n<div class=\"snack\" data-snack-id=\"rk90N44a-\" data-snack-platform=\"ios\" data-snack-preview=\"true\" data-snack-theme=\"light\" style=\"overflow:hidden;background:#fafafa;border:1px solid rgba(0,0,0,.16);border-radius:4px;height:505px;width:100%\"></div>\n","guides/Hybrid-Navigation":"## Common React Navigation API - Hybrid Integration\n\nThis is a purely speculative API that demonstrates how it may be possible to integrate the [JS navigation API](./Common-Navigation-Spec.md) in a hybrid app.\n\n## Setting up a screen\n\nIt should be possible to register new screens from JS into native. In your main bundle:\n\n```\nconst HybridNavigationModule = require('NativeModules').HybridNavigation;\n\nHybridNavigationModule.registerScreens([\n  {\n    type: 'Marketplace',\n    screen: MarketplaceScreen,\n  },\n  {\n  \ttype: 'Product',\n  \tscreen: ProductScreen,\n  },\n]);\n```\n\n## Linking to JS\n\nNow, your native code can open a react screen by type name:\n\n```\n// please pretend this is Obj-C or Java syntax:\nCoreHybridNavigation.openReactScreen('Profile', {id: 123});\n```\n\n## Linking to Native\n\nIf JS product code wants to request navigation to a screen that may *or may not* be in native, it can do this:\n\n```\nconst MarketplaceScreen = ({ navigation }) => (\n  <View>\n    <Button onPress={() => navigation.dispatch({\n      type: 'Product',\n      id: 42,\n    })}>\n      See product 42\n    </Button>\n  </View>\n);\n```\n\nInside the infra:\n\n```\nclass InfraScreen extends React.Component {\n  constructor() {\n    const {initURI, type} = this.props;\n    const ScreenView = ScreenRegistry[type].screen;\n    const router = ScreenView.router;\n    const deepLinkAction = router.getActionForURI(initURI);\n    const initAction = deepLinkAction || {type: 'init'}\n    const nav = router.getStateForAction(initAction);\n    this.state = {\n      nav,\n    };\n    HybridNavigationModule.setNavOptions(this.state.nav);\n  }\n  componentWillUpdate() {\n    HybridNavigationModule.setNavOptions(this.state.nav);\n  }\n  dispatch = (action) => {\n    const {type} = this.props;\n    const ScreenView = ScreenRegistry[type].screen;\n    const {getStateForAction} = ScreenView.router;\n    const newNavState = getStateForAction(action, this.state.nav);\n    if (newNavState !== this.state.nav) {\n      this.setState({ nav: newNavState });\n      return true;\n    }\n    if (action.type === 'URI') {\n      HybridNavigationModule.openURI(action.uri);\n      return true;\n    }\n    if (action.type === NavigationActions.BACK) {\n      HybridNavigationModule.goBack();\n      return true;\n    }\n    HybridNavigationModule.openAction(action);\n    return true;\n  }\n  render() {\n    const {type} = this.props;\n    const ScreenView = ScreenRegistry[type].screen;\n    const navigation = {\n      dispatch: this.dispatch,\n      state: this.state.nav,\n    };\n    return <ScreenView navigation={navigation} />;\n  }\n}\n```\n\n## Setting title\n\n```\nMarketplaceScreen.router = {\n  getStateForAction(action, lastState) {\n    return lastState || {title: 'Marketplace Home'};\n  },\n};\n```\nA HOC could be used to make this feel more elegant.\n\n\n## Disabling/Enabling the right button\n\n```\nconst TestScreen = ({ navigation }) => (\n  <View>\n    <Button onPress={() => navigation.dispatch({\n      type: 'ToggleMyButtonPressability',\n    })}>\n      {navigation.state.rightButtonEnabled ? 'Disable' : 'Enable'} right button\n    </Button>\n    <Text>Pressed {navigation.state} times</Text>\n  </View>\n);\nTestScreen.router = {\n  getStateForAction(action, lastState = {}) {\n    let state = lastState || {\n      rightButtonEnabled: true,\n      rightButtonTitle: 'Tap Me',\n      pressCount: 0,\n    };\n    if (action.type === 'ToggleMyButtonPressability') {\n      state = {\n        ...state,\n        rightButtonEnabled: !state.rightButtonEnabled,\n      };\n    } else if (action.type === 'RightButtonPress') {\n      state = {\n        ...state,\n        pressCount: state.pressCount + 1,\n      };\n    }\n    return state;\n  },\n};\n```\n\n\n## Before JS starts\n\nA JSON file could be defined for native to consume before JS spins up:\n\n```\n{\n  \"screens\": [\n    {\n      \"type\": \"Profile\",\n      \"path\": \"/users/:id?name=:name\",\n      \"params\": {\n        \"name\": \"string\",\n        \"id\": \"number\"\n      },\n      \"title\": \"%name%' s Profile\",\n      \"rightButtonTitle\": \"Message %name%\"\n    },\n    {\n      ...\n    }\n  ]\n}\n```\n\nThis seems like a pain to set up, so we can statically analyze our JS and autogenerate this JSON! If the JS in an app changes, there could be a way for JS to report the new routing configuration to native for use on the next cold start.\n","guides/Navigation-Actions":"# Navigation Actions\n\nAll Navigation Actions return an object that can be sent to the router using `navigation.dispatch()` method.\n\nNote that if you want to dispatch react-navigation actions you should use the action creators provided in this library.\n\nThe following actions are supported:\n* [Navigate](#Navigate) - Navigate to another route\n* [Reset](#reset) - Replace current state with a new state\n* [Back](#Back) - Go back to previous state\n* [Set Params](#SetParams) - Set Params for given route\n* [Init](#Init) - Used to initialize first state if state is undefined\n\nThe action creator functions define `toString()` to return the action type, which enables easy usage with third-party Redux libraries, including redux-actions and redux-saga.\n\n### Navigate\nThe `Navigate` action will update the current state with the result of a `Navigate` action.\n\n- `routeName` - *String* - Required - A destination routeName that has been registered somewhere in the app's router\n- `params` - *Object* - Optional - Params to merge into the destination route\n- `action` - *Object* - Optional - (advanced) The sub-action to run in the child router, if the screen is a navigator. Any one of the actions described in this doc can be set as a sub-action.\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst navigateAction = NavigationActions.navigate({\n\n  routeName: 'Profile',\n\n  params: {},\n\n  action: NavigationActions.navigate({ routeName: 'SubProfileRoute'})\n})\n\nthis.props.navigation.dispatch(navigateAction)\n\n```\n\n\n### Reset\n\nThe `Reset` action wipes the whole navigation state and replaces it with the result of several actions.\n\n- `index` - *number* - required - Index of the active route on `routes` array in navigation `state`.\n- `actions` - *array* - required - Array of Navigation Actions that will replace the navigation state.\n- `key` - *string or null* - optional - If set, the navigator with the given key will reset. If null, the root navigator will reset.\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst resetAction = NavigationActions.reset({\n  index: 0,\n  actions: [\n    NavigationActions.navigate({ routeName: 'Profile'})\n  ]\n})\nthis.props.navigation.dispatch(resetAction)\n\n```\n#### How to use the `index` parameter\nThe `index` param is used to specify the current active route.\n\neg: given a basic stack navigation with two routes `Profile` and `Settings`.\nTo reset the state to a point where the active screen was `Settings` but have it stacked on top of a `Profile` screen, you would do the following:\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst resetAction = NavigationActions.reset({\n  index: 1,\n  actions: [\n    NavigationActions.navigate({ routeName: 'Profile'}),\n    NavigationActions.navigate({ routeName: 'Settings'})\n  ]\n})\nthis.props.navigation.dispatch(resetAction)\n\n```\n\n### Back\n\nGo back to previous screen and close current screen. `back` action creator takes in one optional parameter:\n- `key` - *string or null* - optional - If set, navigation will go back from the given key. If null, navigation will go back anywhere.\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst backAction = NavigationActions.back({\n  key: 'Profile'\n})\nthis.props.navigation.dispatch(backAction)\n\n```\n\n### SetParams\n\nWhen dispatching `SetParams`, the router will produce a new state that has changed the params of a particular route, as identified by the key\n\n- `params` - *object* - required - New params to be merged into existing route params\n- `key` - *string* - required - Route key that should get the new params\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst setParamsAction = NavigationActions.setParams({\n  params: { title: 'Hello' },\n  key: 'screen-123',\n})\nthis.props.navigation.dispatch(setParamsAction)\n\n```\n","guides/Redux-Integration":"# Redux Integration\n\n### Overview For Redux Integration\n1. To handle your app's navigation state in redux, you can pass your own `navigation` prop to a navigator.\n\n2. Once you pass your own navigation prop to the navigator, the default [`navigation`](https://reactnavigation.org/docs/navigators/navigation-prop) prop gets destroyed. You will most probably pass the `navigation` prop's properties that you want to access. Normally  [`state`](https://reactnavigation.org/docs/navigators/navigation-prop#state-The-screen's-current-stateroute) and [`dispatch`](https://reactnavigation.org/docs/navigators/navigation-prop#dispatch-Send-an-action-to-the-router) properties are passed to the navigator. You will learn how to pass those properties further in this guide. Since you have destroyed the default props, if you try to invoke something you have not explicitly passed down, it won't work. So, if you didn't pass `dispatch`  to the navigator and only passes `state` than you can't access `dispatch` further in your Components.\n\n3. The `state` will be fed from the reducer assigned to handle navigation state and the `dispatch` will be redux's default `dispatch`. Thus you will be able to dispatch normal redux actions using `this.props.navigation.dispatch(ACTION)`, reducer will update the navigation state on the basis of dispatched action, the new navigation state will then be passed to the navigator.\n\n### Details Regarding Redux Integration\nWith redux, your app's state is defined by a reducer. Each navigation router effectively has a reducer, called `getStateForAction`. The following is a minimal example of how you might use navigators within a redux application:\n\n```es6\nimport { addNavigationHelpers } from 'react-navigation';\n\nconst AppNavigator = StackNavigator(AppRouteConfigs);\n\nconst initialState = AppNavigator.router.getStateForAction(AppNavigator.router.getActionForPathAndParams('Login'));\n\nconst navReducer = (state = initialState, action) => {\n  const nextState = AppNavigator.router.getStateForAction(action, state);\n\n  // Simply return the original `state` if `nextState` is null or undefined.\n  return nextState || state;\n};\n\nconst appReducer = combineReducers({\n  nav: navReducer,\n  ...\n});\n\nclass App extends React.Component {\n  render() {\n    return (\n      <AppNavigator navigation={addNavigationHelpers({\n        dispatch: this.props.dispatch,\n        state: this.props.nav,\n      })} />\n    );\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  nav: state.nav\n});\n\nconst AppWithNavigationState = connect(mapStateToProps)(App);\n\nconst store = createStore(appReducer);\n\nclass Root extends React.Component {\n  render() {\n    return (\n      <Provider store={store}>\n        <AppWithNavigationState />\n      </Provider>\n    );\n  }\n}\n```\n\nOnce you do this, your navigation state is stored within your redux store, at which point you can fire navigation actions using your redux dispatch function.\n\nKeep in mind that when a navigator is given a `navigation` prop, it relinquishes control of its internal state. That means you are now responsible for persisting its state, handling any deep linking, [Handling the Hardware Back Button in Android](#Handling-the-Hardware-Back-Button-in-Android), etc.\n\nNavigation state is automatically passed down from one navigator to another when you nest them. Note that in order for a child navigator to receive the state from a parent navigator, it should be defined as a `screen`.\n\nApplying this to the example above, you could instead define `AppNavigator` to contain a nested `TabNavigator` as follows:\n\n```es6\nconst AppNavigator = StackNavigator({\n  Home: { screen: MyTabNavigator },\n});\n```\n\nIn this case, once you `connect` `AppNavigator` to Redux as is done in `AppWithNavigationState`, `MyTabNavigator` will automatically have access to navigation state as a `navigation` prop.\n\n## Full example\n\nThere's a working example app with redux [here](https://github.com/react-community/react-navigation/tree/master/examples/ReduxExample) if you want to try it out yourself.\n\n## Mocking tests\n\nTo make jest tests work with your react-navigation app, you need to change the jest preset in the `package.json`, see [here](https://facebook.github.io/jest/docs/tutorial-react-native.html#transformignorepatterns-customization):\n\n\n```json\n\"jest\": {\n  \"preset\": \"react-native\",\n  \"transformIgnorePatterns\": [\n    \"node_modules/(?!(jest-)?react-native|react-navigation)\"\n  ]\n}\n```\n\n## Handling the Hardware Back Button in Android\n\nBy using the following snippet, your nav component will be aware of the back button press actions and will correctly interact with your stack. This is really useful on Android.\n\n```es6\nimport React from \"react\";\nimport { BackHandler } from \"react-native\";\nimport { addNavigationHelpers, NavigationActions } from \"react-navigation\";\n\nconst AppNavigation = TabNavigator(\n  {\n    Home: { screen: HomeScreen },\n    Settings: { screen: SettingScreen }\n  }\n);\n\nclass ReduxNavigation extends React.Component {\n  componentDidMount() {\n    BackHandler.addEventListener(\"hardwareBackPress\", this.onBackPress);\n  }\n  componentWillUnmount() {\n    BackHandler.removeEventListener(\"hardwareBackPress\", this.onBackPress);\n  }\n  onBackPress = () => {\n    const { dispatch, nav } = this.props;\n    if (nav.index === 0) {\n      return false;\n    }\n    dispatch(NavigationActions.back());\n    return true;\n  };\n\n  render() {\n    const { dispatch, nav } = this.props;\n    const navigation = addNavigationHelpers({\n      dispatch,\n      state: nav\n    });\n\n    return <AppNavigation navigation={navigation} />;\n  }\n}\n","guides/Screen-Nav-Options":"\n# Screen Navigation Options\n\nEach screen can configure several aspects about how it gets presented in parent navigators.\n\n#### Two Ways to specify each option\n\n**Static configuration:** Each navigation option can either be directly assigned:\n\n```js\nclass MyScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Great',\n  };\n  ...\n```\n\n**Dynamic Configuration**\n\nOr, the options can be a function that takes the following arguments, and returns an object of navigation options that will override the route-defined and navigator-defined navigationOptions.\n\n- `props` - The same props that are available to the screen component\n  - `navigation` - The [navigation prop](/docs/navigators/navigation-prop) for the screen, with the screen's route at `navigation.state`\n  - `screenProps` - The props passing from above the navigator component\n  - `navigationOptions` - The default or previous options that would be used if new values are not provided\n\n```js\nclass ProfileScreen extends React.Component {\n  static navigationOptions = ({ navigation, screenProps }) => ({\n    title: navigation.state.params.name + \"'s Profile!\",\n    headerRight: <Button color={screenProps.tintColor} {...} />,\n  });\n  ...\n```\n\nThe screenProps are passed in at render-time. If this screen was hosted in a SimpleApp navigator:\n\n```js\n<SimpleApp\n  screenProps={{tintColor: 'blue'}}\n  // navigation={{state, dispatch}} // optionally control the app\n/>\n```\n\n#### Generic Navigation Options\n\nThe `title` navigation option is generic between every navigator. It is used to set the title string for a given screen.\n\n```js\nclass MyScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Great',\n  };\n  ...\n```\n\nUnlike the other nav options which are only utilized by the navigator view, the title option can be used by the environment to update the title in the browser window or app switcher.\n\n#### Default Navigation Options\n\nIt's very common to define `navigationOptions` on a screen, but sometimes it is useful to define `navigationOptions` on a navigator too.\n\nImagine the following scenario:\nYour `TabNavigator` represents one of the screens in the app, and is nested within a top-level `StackNavigator`:\n\n```\nStackNavigator({\n  route1: { screen: RouteOne },\n  route2: { screen: MyTabNavigator },\n});\n```\n\nNow, when `route2` is active, you would like to change the tint color of a header. It's easy to do it for `route1`, and it should also be easy to do it for `route2`. This is what Default Navigation Options are for - they are simply `navigationOptions` set on a navigator:\n\n```js\nconst MyTabNavigator = TabNavigator({\n  profile: ProfileScreen,\n  ...\n}, {\n  navigationOptions: {\n    headerTintColor: 'blue',\n  },\n});\n```\n\nNote that you can still decide to **also** specify the `navigationOptions` on the screens at the leaf level - e.g.  the `ProfileScreen` above. The `navigationOptions` from the screen will be merged key-by-key with the default options coming from the navigator. Whenever both the navigator and screen define the same option (e.g. `headerTintColor`), the screen wins. Therefore, you could change the tint color when `ProfileScreen` is active by doing the following:\n\n```js\nclass ProfileScreen extends React.Component {\n  static navigationOptions = {\n    headerTintColor: 'black',\n  };\n  ...\n}\n```\n\n## Navigation Option Reference\n\nList of available navigation options depends on the `navigator` the screen is added to.\n\nCheck available options for:\n- [`drawer navigator`](/docs/navigators/drawer#Screen-Navigation-Options)\n- [`stack navigator`](/docs/navigators/stack#Screen-Navigation-Options)\n- [`tab navigator`](/docs/navigators/tab#Screen-Navigation-Options)\n","guides/Screen-Navigation-Prop":"\n# Screen Navigation Prop\n\nEach *screen* in your app will receive a navigation prop which contain the following:\n* `navigate` - (helper) link to other screens\n* `state` - screen's current state/routes\n* `setParams` - (helper) make changes to route's params\n* `goBack` - (helper) close active screen and move back\n* `dispatch` - send an action to router\n\n*NOTE:* The `navigation` prop is passed down to every navigation-aware component including navigators. The big exception is that a navigator's `navigation` prop may not have the helper functions (`navigate`, `goBack`, etc); it may only have `state` and `dispatch`. In order to `navigate` using the navigator's `navigation` prop, you will have to `dispatch` using an [action creator](navigation-actions).\n\n*Notes regarding hooking things up with Redux*\n\n> People don't always hook things up to redux correctly, because they mis-understand the navigator's top-level API, where the navigation prop is optional. The navigator will maintain its own state if it doesn't get a navigation prop, but this is not a feature you generally want to use when hooking your app up with redux. For navigators that are nested inside of your main navigator, you always want to pass the screen's navigation prop down. This allows your top-level navigator to communicate and provide state for all the children navigators. Only your top-level router needs to be integrated with redux, because all the other routers are inside it.\n\n## `navigate` - Link to other screens\n\nCall this to link to another screen in your app. Takes the following arguments:\n\n`navigate(routeName, params, action)`\n\n- `routeName` - A destination routeName that has been registered somewhere in the app's router\n- `params` - Params to merge into the destination route\n- `action` - (advanced) The sub-action to run in the child router, if the screen is a navigator. See [Actions Doc](navigation-actions) for a full list of supported actions.\n\n```js\nclass HomeScreen extends React.Component {\n  render() {\n    const {navigate} = this.props.navigation;\n\n    return (\n      <View>\n        <Text>This is the home screen of the app</Text>\n        <Button\n          onPress={() => navigate('Profile', {name: 'Brent'})}\n          title=\"Go to Brent's profile\"\n        />\n      </View>\n     )\n   }\n}\n```\n\n## `state` - The screen's current state/route\n\nA screen has access to its route via `this.props.navigation.state`. Each will return an object with the following:\n\n```js\n{\n  // the name of the route config in the router\n  routeName: 'profile',\n  //a unique identifier used to sort routes\n  key: 'main0',\n  //an optional object of string options for this screen\n  params: { hello: 'world' }\n}\n```\n\n```js\nclass ProfileScreen extends React.Component {\n  render() {\n    const {state} = this.props.navigation;\n    // state.routeName === 'Profile'\n    return (\n      <Text>Name: {state.params.name}</Text>\n    );\n  }\n}\n```\n\n\n## `setParams` - Make changes to route params\n\nFiring the `setParams` action allows a screen to change the params in the route, which is useful for updating the header buttons and title.\n\n```js\nclass ProfileScreen extends React.Component {\n  render() {\n    const {setParams} = this.props.navigation;\n    return (\n      <Button\n        onPress={() => setParams({name: 'Lucy'})}\n        title=\"Set title name to 'Lucy'\"\n      />\n     )\n   }\n}\n```\n\n## `goBack` - Close the active screen and move back\n\nOptionally provide a key, which specifies the route to go back from. By default, goBack will close the route that it is called from. If the goal is to go back *anywhere*, without specifying what is getting closed, call `.goBack(null);`\n\n```js\nclass HomeScreen extends React.Component {\n  render() {\n    const {goBack} = this.props.navigation;\n    return (\n      <View>\n        <Button\n          onPress={() => goBack()}\n          title=\"Go back from this HomeScreen\"\n        />\n        <Button\n          onPress={() => goBack(null)}\n          title=\"Go back anywhere\"\n        />\n        <Button\n          onPress={() => goBack('screen-123')}\n          title=\"Go back from screen-123\"\n        />\n      </View>\n     )\n   }\n}\n```\n\n*Going back from a specific screen*\n\nConsider the following navigation stack history:\n```... \nnavigation.navigate(SCREEN_KEY_A);\n...\nnavigation.navigate(SCREEN_KEY_B);\n...\nnavigation.navigate(SCREEN_KEY_C);\n...\nnavigation.navigate(SCREEN_KEY_D);\n```\n\nNow you are on *screen D* and want to go back to *screen A* (popping D, C, and B).\nThen you need to supply a key to goBack *FROM*:\n\n```\nnavigation.goBack(SCREEN_KEY_B) // will go to screen A FROM screen B\n```\n\n## `dispatch` - Send an action to the router\n\nUse dispatch to send any navigation action to the router. The other navigation functions use dispatch behind the scenes.\n\nNote that if you want to dispatch react-navigation actions you should use the action creators provided in this library.\n\nSee [Navigation Actions Docs](navigation-actions) for a full list of available actions.\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst navigateAction = NavigationActions.navigate({\n  routeName: 'Profile',\n  params: {},\n\n  // navigate can have a nested navigate action that will be run inside the child router\n  action: NavigationActions.navigate({ routeName: 'SubProfileRoute'})\n})\nthis.props.navigation.dispatch(navigateAction)\n\n```\n","guides/Screen-Tracking":"## Screen tracking and analytics\n\nThis example shows how to do screen tracking and send to Google Analytics. The approach can be adapted to any other mobile analytics SDK. \n\n### Screen tracking\n\nWhen using built-in navigation container, we can use `onNavigationStateChange` to track the screen.\n\n```js\nimport { GoogleAnalyticsTracker } from 'react-native-google-analytics-bridge';\n\nconst tracker = new GoogleAnalyticsTracker(GA_TRACKING_ID);\n\n// gets the current screen from navigation state\nfunction getCurrentRouteName(navigationState) {\n  if (!navigationState) {\n    return null;\n  }\n  const route = navigationState.routes[navigationState.index];\n  // dive into nested navigators\n  if (route.routes) {\n    return getCurrentRouteName(route);\n  }\n  return route.routeName;\n}\n\nconst AppNavigator = StackNavigator(AppRouteConfigs);\n\nexport default () => (\n  <AppNavigator\n    onNavigationStateChange={(prevState, currentState) => {\n      const currentScreen = getCurrentRouteName(currentState);\n      const prevScreen = getCurrentRouteName(prevState);\n\n      if (prevScreen !== currentScreen) {\n        // the line below uses the Google Analytics tracker\n        // change the tracker here to use other Mobile analytics SDK.\n        tracker.trackScreenView(currentScreen);\n      }\n    }}\n  />\n);\n```\n\n### Screen tracking with Redux\n\nWhen using Redux, we can write a Redux middleware to track the screen. For this purpose,\nwe will reuse `getCurrentRouteName` from the previous section.\n\n```js\nimport { NavigationActions } from 'react-navigation';\nimport { GoogleAnalyticsTracker } from 'react-native-google-analytics-bridge';\n\nconst tracker = new GoogleAnalyticsTracker(GA_TRACKING_ID);\n\nconst screenTracking = ({ getState }) => next => (action) => {\n  if (\n    action.type !== NavigationActions.NAVIGATE\n    && action.type !== NavigationActions.BACK\n  ) {\n    return next(action);\n  }\n\n  const currentScreen = getCurrentRouteName(getState().navigation);\n  const result = next(action);\n  const nextScreen = getCurrentRouteName(getState().navigation);\n  if (nextScreen !== currentScreen) {\n    // the line below uses the Google Analytics tracker\n    // change the tracker here to use other Mobile analytics SDK.\n    tracker.trackScreenView(nextScreen);\n  }\n  return result;\n};\n\nexport default screenTracking;\n```\n\n### Create Redux store and apply the above middleware\n\nThe `screenTracking` middleware can be applied to the store during its creation. See [Redux Integration](Redux-Integration.md) for details.\n\n```js\nconst store = createStore(\n  combineReducers({\n    navigation: navigationReducer,\n    ...\n  }),\n  applyMiddleware(\n    screenTracking,\n    ...\n    ),\n);\n```\n","guides/Web-Integration":"# Web Integration\n\nReact Navigation routers work on web and allow you to share navigation logic with native apps. The views currently bundled in `react-navigation` currently only work on React Native, but that may change with future-facing projects like [react-primitives](https://github.com/lelandrichardson/react-primitives).\n\n## Example App\n\n[This website](https://reactnavigation.org/) is [built with](https://github.com/react-community/react-navigation/blob/master/website/) React Navigation, specifically using `createNavigator` and `TabRouter`.\n\nSee the source code of the site here: [App.js](https://github.com/react-community/react-navigation/blob/master/website/src/App.js).\n\nTo see how the app gets rendered on the server, see [Server.js](https://github.com/react-community/react-navigation/blob/master/website/src/Server.js). On the browser, the App wakes up and gets rendered with [BrowserAppContainer.js](https://github.com/react-community/react-navigation/blob/master/website/src/BrowserAppContainer.js).\n\n\n## More Coming Soon\n\nSoon this guide will be replaced with a more thorough walkthrough of react-navigation usage on the web.\n"}